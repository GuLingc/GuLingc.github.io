<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React项目搭建</title>
    <url>/2023/07/15/React%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><a name="RMA4X"></a></p>
<h4 id="1-工具：搭建React项目的脚手架"><a href="#1-工具：搭建React项目的脚手架" class="headerlink" title="1.工具：搭建React项目的脚手架"></a>1.工具：搭建React项目的脚手架</h4><ul>
<li>create-react-app 项目名称</li>
</ul>
<p>如果采用<strong>create-react-app 项目名称</strong>的方式搭建脚手架则生成的项目中<strong>不含TS配置</strong>需要自己手动搭建TS配置。存在的弊端如下：</p>
<ul>
<li>弊端一：项目基于webpack，webpack所有配置是隐藏的</li>
<li>弊端二：TS React项目配置难度较大。并且将ts代码转化成js代码的编译方式有TS Compiler和Lable两种方式，两者最好都要配置，难度较大。</li>
<li>**create-react-app 项目名称 –template typescript	**—&gt;利用git bash窗口创建，如果利用黑窗口前面加npm或npx</li>
</ul>
<p>上面脚手架配置的好处：</p>
<ul>
<li>create-react-app：创建了一个react项目</li>
<li>后面内容的存在同时配置TS的支持<br><a name="ZEINP"></a></li>
</ul>
<h4 id="2-项目配置"><a href="#2-项目配置" class="headerlink" title="2.项目配置"></a>2.项目配置</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 配置项目的icon</li>
<li><input checked="" disabled="" type="checkbox"> 配置项目的标题</li>
<li><input checked="" disabled="" type="checkbox"> 配置项目别名等（craco.config.ts）—&gt;配置src的别名放置出现多个..&#x2F;..&#x2F;的嵌套</li>
</ul>
<p>因为别名的配置是基于webpack配置的，它的东西又被隐藏了，所以需要借助craco:create-react-app config。因为react5.0版本太新，所以在安装craco的时候也需要安装最新版本 <strong>npm install @craco&#x2F;craco@alpha -D</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 配置tsconfig.json</li>
</ul>
<hr>
<ol>
<li>配置项目别名步骤<ol>
<li>安装craco</li>
</ol>
</li>
</ol>
<p>如果react采用的是4.0版本采用 npm install @craco&#x2F;craco -D<br />如果react采用的是5.0版本使用 npm install @craco&#x2F;craco@alpha -D</p>
<pre><code>  2. 创建craco.config.js文件
</code></pre>
<p>在根目录下即src外层创建该文件；</p>
<pre><code>  3. 配置文件内容
</code></pre>
<p>__dirname:当前目录；<br />craco.config.js文件内容代码配置如下：<br /><img src="/img/study/craco.png" alt="image.png"><br />然后在tsconfig.json文件里配置路径的相关内容，否则在其他文件中无法使用<img src="/img/study/tsconfig.png" alt="image.png"><br />并且将package.json中前三个的react-script改成craco,进行合并使用，否则在编译生成页面的时候仍会报错<br /><img src="/img/study/pack.png" alt="image.png"></p>
<hr>
<p><a name="bf73J"></a></p>
<h4 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3.代码规范"></a>3.代码规范</h4><p><a name="KTJUH"></a></p>
<h5 id="集成editorgonfid配置"><a href="#集成editorgonfid配置" class="headerlink" title="集成editorgonfid配置"></a>集成editorgonfid配置</h5><p>editorConfig配置有助于为不同的IDE编译器上处理同一个项目的多个开发人员维护一致的编码风格。<br />新建.editorconfig文件，无后缀</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># http://editorconfig.org</span></span><br><span class="line"></span><br><span class="line"><span class="string">root</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[<span class="string">*</span>] <span class="comment"># 表示所有文件适用</span></span><br><span class="line"><span class="string">charset</span> <span class="string">=</span> <span class="string">utf-8</span> <span class="comment"># 设置文件字符集为 utf-8</span></span><br><span class="line"><span class="string">indent_style</span> <span class="string">=</span> <span class="string">space</span> <span class="comment"># 缩进风格（tab | space）</span></span><br><span class="line"><span class="string">indent_size</span> <span class="string">=</span> <span class="number">2</span> <span class="comment"># 缩进大小</span></span><br><span class="line"><span class="string">end_of_line</span> <span class="string">=</span> <span class="string">lf</span> <span class="comment"># 控制换行类型(lf | cr | crlf)</span></span><br><span class="line"><span class="string">trim_trailing_whitespace</span> <span class="string">=</span> <span class="literal">true</span> <span class="comment"># 去除行尾的任意空白字符</span></span><br><span class="line"><span class="string">insert_final_newline</span> <span class="string">=</span> <span class="literal">true</span> <span class="comment"># 始终在文件末尾插入一个新行</span></span><br><span class="line"></span><br><span class="line">[<span class="string">*.md</span>] <span class="comment"># 表示仅 md 文件适用以下规则</span></span><br><span class="line"><span class="string">max_line_length</span> <span class="string">=</span> <span class="string">off</span></span><br><span class="line"><span class="string">trim_trailing_whitespace</span> <span class="string">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><a name="RYthi"></a></p>
<h5 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h5><p>prettier保持代码的某一种风格，格式化代码，使其更加美观</p>
<pre><code>  1. 安装prettier:  npm install prettier -D
  2. 在项目的根目录下创建.prettierrc文件
  3. 测试prettier是否生效
     - 在代码中保存代码；
     - 配置一次性修改的命令
</code></pre>
<p>在package.json中配置一个script</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;prettier&quot;</span><span class="punctuation">:</span><span class="string">&quot;prettier --writer .&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以输入命令手动格式化所有未被忽略的文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">npm run prettier</span><br></pre></td></tr></table></figure>

<p>   1.4**.忽略不被格式化的文件**</p>
<ul>
<li>在根目录下创建.prettierignore文件</li>
<li>在文件中写入要忽略的文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /build/*</span></span><br><span class="line"><span class="comment"># .local</span></span><br><span class="line"><span class="comment"># .output.js</span></span><br><span class="line"><span class="comment"># /node_modules/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># **/*.svg</span></span><br><span class="line"><span class="comment"># **/*.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /public/*</span></span><br></pre></td></tr></table></figure>

<p><a name="Dneg3"></a></p>
<h5 id="使用EsLint检测"><a href="#使用EsLint检测" class="headerlink" title="使用EsLint检测"></a>使用EsLint检测</h5><pre><code>  1. 安装eslint:  npm install selint -D
  2. 由于eslint的配置比较多所以采用命令的方式自动生成配置文件
</code></pre>
<ul>
<li>对eslint进行初始化：npx eslint –init</li>
<li>输入y生成配置文件</li>
<li>在三个选项中选择第二个，检测错误并发现问题，第三个选项多个一个强制代码转换，由于上面配置过prettier所以不需要</li>
<li>选择第一个js模块化</li>
</ul>
<p><img src="/img/study/eslintFirst.png" alt="image.png"></p>
<ul>
<li>因为这个项目是React项目所以选择React</li>
<li>因为使用了TS所以是yes</li>
<li>选择浏览器Browser;选择js文件；选择yes;选择npm</li>
</ul>
<p><img src="/img/study/eslintSecond.png" alt="image.png"><br />1.3 修改生成的配置文件<br />     由于上方生成的配置文件只选择在浏览器环境下运行，而项目中又参杂了node所以为了保证可以在node环境下进行，需要在配置文件的“env”里加入:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;node&quot;</span>:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>为了使require正常使用要在配置文件的rules中加入如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;@typescript-eslint/no-var-requires&#x27;</span>: <span class="string">&#x27;off&#x27;</span></span><br></pre></td></tr></table></figure>

<p>1.4  vsCode需要安装eslint插件<br />1.5解决eslint和prettier冲突的问题：<br />安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装。<br />npm install eslint-plugin-prettier eslint-config-prettier -D<br />安装成功之后在.eslintrc.js中增加下方代码：使eslint与prettier代码风格一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;plugin:prettier/recommended&#x27;</span></span><br></pre></td></tr></table></figure>

<p>prettier和eslint存在冲突，暂时不要用尤其是eslint;<br><a name="mZATs"></a></p>
<h4 id="4-项目目录结构的划分"><a href="#4-项目目录结构的划分" class="headerlink" title="4.项目目录结构的划分"></a>4.项目目录结构的划分</h4><ul>
<li>assets放置静态资源：例如：css,img</li>
<li>base-ui多个项目使用的共同组件</li>
<li>components:存放当前项目中多出使用到的共同组件</li>
<li>hook:自定义hook———–&gt;一般不单独建文件夹</li>
<li>router</li>
<li>store</li>
<li>service:网络请求</li>
<li>utils:存放工具，例如：全局自定义弹窗</li>
<li>views:存放视图，展示不同页面的组件<br><a name="Bya3Z"></a></li>
</ul>
<h4 id="5-对CSS样式的重置"><a href="#5-对CSS样式的重置" class="headerlink" title="5.对CSS样式的重置"></a>5.对CSS样式的重置</h4><ul>
<li>normalize.css:  npm install normalize.css</li>
</ul>
<p>在tsx文件中引入normalize.css,从而对默认的css进行重置</p>
<ul>
<li>reset.less：自己在静态文件夹下的css文件中建立文档，定义 jk重置的css样式</li>
</ul>
<p>如果使用less需要安装指定版本：<br />npm install <a href="mailto:&#x63;&#114;&#x61;&#99;&#x6f;&#x2d;&#108;&#101;&#115;&#x73;&#x40;&#50;&#46;&#49;&#46;&#48;&#x2d;&#97;&#x6c;&#x70;&#104;&#97;&#46;&#48;">&#x63;&#114;&#x61;&#99;&#x6f;&#x2d;&#108;&#101;&#115;&#x73;&#x40;&#50;&#46;&#49;&#46;&#48;&#x2d;&#97;&#x6c;&#x70;&#104;&#97;&#46;&#48;</a><br><a name="Q38Z8"></a></p>
<h4 id="6-路由的配置"><a href="#6-路由的配置" class="headerlink" title="6.路由的配置"></a>6.路由的配置</h4><pre><code>  1. 路由的搭建：npm install react-router-dom
  2. 在写路由的时候与vue使用compoent不同的是React用的element，并且element后面跟的是组件实例（&lt;Discover /&gt;）而非Discover。由于组件实例属于jsx语法，所以写路有的文件不能是.ts应该是.tsx。凡是tsx文件都需要引入React(import React from &#39;react&#39;)。
  3. 如果使用路由，最外层的index.tsx中的APP必须被router包裹
</code></pre>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;normalize.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./assets/css/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;@/App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<pre><code>1.4：写路由组件的一般做法：
</code></pre>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123;memo&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">ReactNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">//如果想要读取组件中包括的子组件需要定义children,因为props本身中没有children，不能直接读取传入的子组件</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>; <span class="comment">//传入children写，不传则去掉</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  height?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式一：直接对props进行类型约束：props:IProps</span></span><br><span class="line"><span class="comment">// const Download = (props: IProps) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;div&gt;name:&#123;props.name&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;div&gt;age:&#123;props.age&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;div&gt;height:&#123;props.height&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   );</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：借助ts泛型</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Download</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>name:&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>age:&#123;props.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>height:&#123;props.height&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最好使用memo函数，它的导出性能比较好</span></span><br><span class="line"><span class="comment">// export default Download;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Download</span>)</span><br></pre></td></tr></table></figure>

<p>1.5react与vue二级路由的不同之处：</p>
<ul>
<li>vue的二级路由的path不用加一级路由的路径</li>
<li>react的二级路由的path需要加一级路由的路径否则会报错（如：&#x2F;discover&#x2F;recommend）<br><a name="XmGJ7"></a></li>
</ul>
<h4 id="7-配置react基本代码的一键生成模板"><a href="#7-配置react基本代码的一键生成模板" class="headerlink" title="7.配置react基本代码的一键生成模板"></a>7.配置react基本代码的一键生成模板</h4><p>已知tsx文件基础的模板代码格式如下：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="variable constant_">FC</span>, <span class="title class_">ReactNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPprops</span> &#123;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Djradio</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">IPprops</span>&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Djradio<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Djradio</span>);</span><br></pre></td></tr></table></figure>

<p>利用工具自动生成代码时将可变的文件名称（如：Djradio）改成${1:Home},生成的代码如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;react typescript&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsreact&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;import React, &#123; memo &#125; from \&quot;react\&quot;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;import type &#123; FC, ReactNode &#125; from \&quot;react\&quot;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;interface IPprops &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;  children?: ReactNode;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;const $&#123;1:Home&#125;: FC&lt;IPprops&gt; = () =&gt; &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;  return &lt;div&gt;$&#123;1:Home&#125;&lt;/div&gt;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&#125;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;export default memo($&#123;1:Home&#125;);&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react typescript&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>点击Vscode-&gt;文件-&gt;首选项-&gt;配置用户片段代码-&gt;输入Typescriptreact-&gt;将得到的代码粘贴<br />因为上方代码的prefix的值时tsreact所以在一个新的tsx文件中输入tsreact回车会自动生成react的基础代码。<br><a name="ei0TE"></a></p>
<h4 id="8-状态管理"><a href="#8-状态管理" class="headerlink" title="8.状态管理"></a>8.状态管理</h4><p>状态管理选择：</p>
<ul>
<li>redux:目前React中使用最多的状态管理库；</li>
<li>@reduxjs&#x2F;toolkit:redux工具，更方便的使用redux</li>
</ul>
<p><strong>操作：</strong><br />不需要单独安装redux,只需要如下步骤：<br />npm insatll @reduxjs&#x2F;toolkit react-dom<br />接着在store文件夹中创建index.ts文件,编写store内容：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>在最外层的index.tsx文件中导入store和Provider，Proviindex.tsxder标签位于最外层，使其他页面可以利用store。</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;normalize.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./assets/css/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;@/App&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果想要保存数据可以在store中创建一个文件夹modules,然后在其下面新建一个ts文件（如counter.ts文件）。<strong>在这个文件中及时initalState（初始化）和reducers中无内容也要书写，因为他们和name是必写内容，否则会报错。</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  <span class="attr">initialState</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;Hello Redux&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span></span><br></pre></td></tr></table></figure>

<p>然后导出的内容需要放在store里面否则无效。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&quot;./modules/counter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">counter</span>: counterReducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p><a name="k85va"></a></p>
<h4 id="9-网络请求封装axios"><a href="#9-网络请求封装axios" class="headerlink" title="9.网络请求封装axios"></a>9.网络请求封装axios</h4><pre><code>  1. 安装axios
</code></pre>
<p>npm install axios<br />由于最新班的axios版本过高会有报错，所以安装1.1版本<br />npm install <a href="mailto:&#97;&#x78;&#x69;&#x6f;&#x73;&#64;&#x31;&#x2e;&#49;&#46;&#x30;">&#97;&#x78;&#x69;&#x6f;&#x73;&#64;&#x31;&#x2e;&#49;&#46;&#x30;</a></p>
<pre><code>  2. 1
     &lt;a name=&quot;sFgV1&quot;&gt;&lt;/a&gt;
</code></pre>
<h4 id="10-如何打包项目："><a href="#10-如何打包项目：" class="headerlink" title="10.如何打包项目："></a>10.如何打包项目：</h4><pre><code>  1. npm run build
  2. 打包完成之后在本地跑起来：npm install -g serve
  3. 启动服务器以build作为资源：serve -s build
     &lt;a name=&quot;blAiO&quot;&gt;&lt;/a&gt;
</code></pre>
<h4 id="11-css-in-js库"><a href="#11-css-in-js库" class="headerlink" title="11.css-in-js库"></a>11.css-in-js库</h4><p>react是用js写html的框架，为了在react框架中使用js编写一切代码，使用css-in-js库编写css代码，<strong>style-components是近期使用人数最多的css-in-js库</strong>，它的优点如下：</p>
<ul>
<li>可以编写实际的CSS代码来设计组件样式，也不需要组件和样式之间的映射，即创建后就是一个正常的React 组件，直接在JSX中引入即可</li>
<li>在一个组件内会将结构、样式和逻辑写在一起，虽然这违背了关注点分离的原则，但是这有利于组件间的隔离。为了顺应组件化的潮流</li>
<li>使用styled-components不需要再使用className属性来控制样式，而是将样式写成更具语义化的组件的形式</li>
<li>使用style-components会随机生成一个class名称，这样不会污染到全局变量，当然因为随机生成，维护会增加难度</li>
</ul>
<p><strong>使用步骤：</strong></p>
<ul>
<li>安装style-components:npm install styled-components -D</li>
<li>在引入和使用styled-components之前需要先对其进行类型声明否则会报错。</li>
</ul>
<p>类型声明的几种形式：</p>
<ul>
<li>typescript内置DOM</li>
<li>第三方：<ul>
<li>库内部已经有类型声明（eg：axios）</li>
<li>react&#x2F;react-dom&#x3D;&gt;@types&#x2F;react @types&#x2F;react-dom</li>
<li>自己写的类型声明</li>
</ul>
</li>
<li>解决方式： npm i –save-dev @types&#x2F;styled-components<br><a name="uGWID"></a></li>
</ul>
<h4 id="12-react的第三方库-antd"><a href="#12-react的第三方库-antd" class="headerlink" title="12.react的第三方库-antd"></a>12.react的第三方库-antd</h4><ul>
<li>安装antd:npm install antd –save</li>
<li>如果想要使用图标需要单独再安装一个图标库：npm install –save @ant-design&#x2F;icons<br><a name="W8YPl"></a></li>
</ul>
<h4 id="13-动态添加classname"><a href="#13-动态添加classname" class="headerlink" title="13.动态添加classname"></a><a href="https://blog.csdn.net/sheep_yyx/article/details/125661895">13.动态添加classname</a></h4><p>安装classname库，当利用map之类动态数据遍历的时候可以动态添加classname<br />npm install classname</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>html面试基础(一)</title>
    <url>/2023/08/01/html%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(%E4%B8%80)/</url>
    <content><![CDATA[<p><strong>html知识体系图片:</strong><a href="https://juejin.cn/post/6905294475539513352"><strong>https://juejin.cn/post/6905294475539513352</strong></a></p>
<h3 id="标红重点（考察很多）"><a href="#标红重点（考察很多）" class="headerlink" title="标红重点（考察很多）"></a><label style="color:rgb(223, 42, 63)">标红重点（考察很多）</label></h3><h4 id="src和href的区别："><a href="#src和href的区别：" class="headerlink" title="src和href的区别："></a><label style="color:rgb(223, 42, 63)">src和href的区别：</label></h4><p>src和ref都是用来引入外部的资源，它们的区别如下：</p>
<ul>
<li>src:表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应用到文档内，如请求js脚本。当浏览器解析到该元素时会暂停其他资源的下载和处理，直到将该资源加载，编译，执行完毕，所以一般js脚本会放到页面的底部。</li>
<li>href:表示超文本引用，它指向一些网络资源，建立和当前元素或文本的链接关系。当浏览器识别到它指向的文件时，就会并行下载资源不会停止对当前文档的处理。常用在a,link标签上。</li>
</ul>
<h4 id="对Html语义化的理解"><a href="#对Html语义化的理解" class="headerlink" title="对Html语义化的理解"></a><label style="color:rgb(223, 42, 63)">对Html语义化的理解</label></h4><p>语义化是根据内容的结构化（内容语义化）,选择合适的标签（代码语义化）。通俗的来讲就是用正确的代码，做正确的事情。<br>语义化的优点：</p>
<ul>
<li>对机器友好，带有语义的文字表现力丰富，，更适合搜索引擎的爬虫爬取有效信息，有利于SE0（搜索引擎优化）；</li>
<li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发和维护。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;header&gt;&lt;/header&gt;</span>  <span class="string">头部</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;nav&gt;&lt;/nav&gt;</span>  <span class="string">导航栏</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;section&gt;&lt;/section&gt;</span>  <span class="string">区块（有语义化的div）</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;main&gt;&lt;/main&gt;</span>  <span class="string">主要区域</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;article&gt;&lt;/article&gt;</span>  <span class="string">主要内容</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;aside&gt;&lt;/aside&gt;</span>  <span class="string">侧边栏</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;footer&gt;&lt;/footer&gt;</span>  <span class="string">底部</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="script标签中defer和async的区别"><a href="#script标签中defer和async的区别" class="headerlink" title="script标签中defer和async的区别"></a><label style="color:rgb(223, 42, 63)">script标签中defer和async的区别</label></h4><p><code>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本</code>。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。<br>下图可以直观的看出三者的区别：<br><img src="/img/study/defer.png" alt="image.png"><br>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。<br><strong>defer和async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其<code>区别</code>如下：</p>
<ul>
<li><code>执行顺序</code>：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li>
<li><code>脚本是否并行执行</code>：async属性，表示后续文档的加载和执行js脚本的加载和执行时并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li>
</ul>
<h4 id="HTML5有哪些更新"><a href="#HTML5有哪些更新" class="headerlink" title="HTML5有哪些更新"></a><label style="color:rgb(223, 42, 63)">HTML5有哪些更新</label></h4><h5 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h5><ul>
<li>header：定义文档的页眉（头部）</li>
<li>nav：定义导航栏链接部分</li>
<li>footer：定义文档或节的页脚（底部）</li>
<li>article：定义文章内容</li>
<li>section：定义文档中的节（section,区段）</li>
<li>aside：定义所处内容之外的内容（侧边）</li>
</ul>
<h5 id="媒体标签"><a href="#媒体标签" class="headerlink" title="媒体标签"></a>媒体标签</h5><h5 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h5><h5 id="进度条，度量器"><a href="#进度条，度量器" class="headerlink" title="进度条，度量器"></a>进度条，度量器</h5><h5 id="DOM查询操作"><a href="#DOM查询操作" class="headerlink" title="DOM查询操作"></a>DOM查询操作</h5><h5 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h5><p>HTML5提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>localStorage -没有时间限制的数据存储</li>
<li>sessionStorage -针对一个session的数据存储</li>
<li>拓展：</li>
</ul>
<p><strong><code>LocalStorage:</code></strong><br>存入数据：localStorage.setItem(key,value)调用一次存储一次数据；<br>取出数据：localStorage.getItem(key)<br>全部清除：localStorage.clear()<br>清除单个：localStorage.remove(key)<br><strong><code>SessionStorage:</code></strong><br>存入数据：sessionStorage.setItem(key,value)<br>取出数据：sessionStorage.getItem(key)<br>全部清除：sessionStorage.clear()<br>清除单个：sessionStorage.remove(key)<br><strong><code>localStorage/sessionStorage的共同之处：</code></strong></p>
<ul>
<li>存储大小为5M</li>
<li>不会发送到服务器</li>
</ul>
<p><strong><code>两者的区别：</code></strong></p>
<ul>
<li>sessionStorage存储数据不仅限制在同源，还限制在同一窗口。可以理解为当取数据的页面和存数据的页面不是同一个取到的数据就是null.</li>
<li>localStorage存储的数据只要不清除，就永久有效；sessionStorage存储的数据只要窗口一关闭，就失效。</li>
</ul>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>
<li>拖放：即抓取对象以后拖放到另一个位置。设置元素可拖放：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>画布(canvas)： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SVG：SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li>
<li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li>
</ul>
<h3 id="考察较多"><a href="#考察较多" class="headerlink" title="考察较多"></a><label style="color:rgb(236, 170, 4)">考察较多</label></h3><h4 id="DOCTYPE-文档类型-的作用"><a href="#DOCTYPE-文档类型-的作用" class="headerlink" title="DOCTYPE(文档类型)的作用"></a><label style="color:rgb(236, 170, 4)">DOCTYPE(文档类型)的作用</label></h4><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。<br>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p>
<ul>
<li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>
<li>**BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>
</ul>
<h4 id="简述web-worker"><a href="#简述web-worker" class="headerlink" title="简述web worker"></a><label style="color:rgb(236, 170, 4)">简述web worker</label></h4><p>在HTML页面中，如果在执行脚本时，页面的状态是不可相应的，知道脚本执行完成之后，页面才变成可相应的。web worker是运行在后台的js,独立于其他脚本，不会影响页面的性能。并且通过postMessage将结果回转到主线程。这样在进行复杂操作的时候就不会影响主线程了。<br>如何创建web worker:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 1.检测浏览器对于web worker的支持性</li>
<li><input checked="" disabled="" type="checkbox"> 2.创建web worker文件（js,回调函数等）</li>
<li><input checked="" disabled="" type="checkbox"> 3.创建web worker对象</li>
</ul>
<h4 id="title与h1的区别，b与strong的区别，i与em的区别？"><a href="#title与h1的区别，b与strong的区别，i与em的区别？" class="headerlink" title="title与h1的区别，b与strong的区别，i与em的区别？"></a><label style="color:rgb(236, 170, 4)">title与h1的区别，b与strong的区别，i与em的区别？</label></h4><ul>
<li>title属性没有明确意义指标的标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li>
<li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单的加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎（SEO）更侧重strong标签。</li>
<li><strong>i内容展示为斜体，em便是强调得文本</strong></li>
</ul>
<h4 id="head-标签有什么作用，其中什么标签必不可少？"><a href="#head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="head 标签有什么作用，其中什么标签必不可少？"></a><label style="color:rgb(236, 170, 4)">head 标签有什么作用，其中什么标签必不可少？</label></h4><pre><code> 标签用于定义文档的头部，它是所有头部元素的容器中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供信息等。 
</code></pre>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。<br>下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;</code>。其中 <code>&lt;title&gt;定义文档的标题,它是 head 部分中唯一必需的元素</code>。</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>node基础概念</title>
    <url>/2023/07/29/node%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><a name="IHs7V"></a></p>
<h4 id="1-跨域产生的原因以及解决方案"><a href="#1-跨域产生的原因以及解决方案" class="headerlink" title="1.跨域产生的原因以及解决方案"></a>1.跨域产生的原因以及解决方案</h4><ol>
<li>什么是<code>跨域</code>？<ol>
<li>广义：指一个域下的文档或脚本试图去请求另一个域下的资源</li>
<li>狭义：浏览器不能执行其他网站的脚本，是由浏览器的<a href="https://baike.baidu.com/item/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/3927875">同源策略</a>限制的一类请求场景，从一个域名的网页去请求另一个域名的资源时，域名，端口，协议任一不同，都是跨域。</li>
</ol>
</li>
<li>为什么会产生跨域？</li>
</ol>
<p><code>跨域是因为浏览器的同源策略的限制</code>，是浏览器的一种安全机制，服务端之间是不存在跨域的。所谓的同源指的是两个页面具有相同放入<code>协议，主机和端口，三者任一不相同</code>就会产生跨域。<br />跨域举例：<img src="/img/study/%E8%B7%A8%E5%9F%9F.png" alt="image.png"><br>3. 跨域的解决方案</p>
<pre><code>  1. jsonp跨域
</code></pre>
<p><code>jsonp</code>(JSON with Padding),是json的一种“使用模式”，可以让页面跨域读取数据，其本质是利用script标签的开放策略，浏览器传递callback参数到后端，后端返回数据时会将callback参数作为函数名来包裹数据，从而浏览器久可以跨域请求数据并制定函数来自动处理返回数据。</p>
<pre><code>  2. 跨域资源共享（cors）
</code></pre>
<p>跨域资源共享是一个W3C标准，允许浏览器向跨域服务器发送请求，从而客服ajax只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前，所有主流浏览器是同XMLHttpRequest对象都可支持该功能，IE8和IE8需要使用XDomainRequest对象进行兼容。<br />CORS整个通信过程都是浏览器自动完成，浏览器一旦发现ajax请求跨源，就会自动在头信息中增加Origin字段，用来说明本次请求来自哪个源（协议+域名+端口）。因此，实现CORS通信的关键是服务器，需要服务器配置Access-Control-Allow-Origin头信息。当CORS请求需要携带cookie时，需要服务端配置Access-Control-Allow-Credentials头信息，前端也需要设置withCredentials。</p>
<pre><code>  3. 服务器代理
</code></pre>
<p>服务器代理，顾名思义即在发送跨域请求时，后端进行代理中转请求至服务器端，然后将获取的数据返回给前端。<br />一般适用于以下场景：</p>
<ul>
<li>针对IE7及以下浏览器摒弃Flash插件的情况，配置代理接口与前端页面同源，并中转目标服务器接口，则ajax请求不存在跨域问题。</li>
<li>外网前端页面无法访问内网接口，配置代理接口允许前端页面访问，并中转内网接口，则外网前端页面可以跨域访问内网接口。</li>
</ul>
<h4 id="2-body-parser这个中间件是做什么用的？"><a href="#2-body-parser这个中间件是做什么用的？" class="headerlink" title="2.body-parser这个中间件是做什么用的？"></a>2.body-parser这个中间件是做什么用的？</h4><p><code>body-parser</code>是一个<code>Node.js中间件</code>，用于解析HTTP请求中的请求体（RequestBody）,并将其转化为JSON格式或其它格式的数据对象。它可以帮助开发者方便的从POST,PUT,DELETE等请求中获取请求体数据，并进行相应的处理。具体来说，body-parser支持以下几种请求体数据格式：</p>
<pre><code>  1. JSON格式：通过json()方式解析JSON格式的请求体数据，并将其转换为JS对象
  2. URL编码格式：通过urlencoded()方法解析URL编码格式的请求体数据，并将其转换为JS对象
  3. 多部分数据格式：通过multipart()方法解析多部份数据格式的请求体数据，并将其转换为JS对象。
</code></pre>
<p>例子：简单实用body-parser解析请求体数据的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 URL 编码格式的请求体数据</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 JSON 格式的请求体数据</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">json</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 POST 请求</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`username: <span class="subst">$&#123;username&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Login Success!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running on http://localhost:3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面使用body-parser中间件分别解析了URL编码格式和JSON格式的请求体数据，并通过<code>req.body获取请求体数据对象</code>。在POST请求处理的函数中，打印了用户输入的用户名和密码，并返回了一个登录成功对的响应消息。<br />在使用body-parser中间件时需要根据实际情况选择合适的解析方法，并注意配置参数，以<code>防止出现安全漏洞和错误数据</code>。同时，在处理HTTP请求时，需要对请求体数据进行有效性验证和安全性检查，以保证数据的可靠性和完整性。<br><a name="cmj9f"></a></p>
<h4 id="3-什么是Koa"><a href="#3-什么是Koa" class="headerlink" title="3.什么是Koa?"></a>3.什么是Koa?</h4><p>nodejs中除了express框架，另一个非常流行的Node Web服务器框架就是Koa。<br />Koa是一个精简的node框架，最大的特点是独特的中间件流程控制，典型的洋葱模型。<br><a name="vCEni"></a></p>
<h4 id="4-对Koa洋葱模型的理解"><a href="#4-对Koa洋葱模型的理解" class="headerlink" title="4.对Koa洋葱模型的理解"></a>4.对Koa洋葱模型的理解</h4><p><code>Koa框架</code>是一个Node.js的<code>Web应用程序框架</code>，它通过中间件机制实现了业务逻辑的分层和复用。Koa中使用的中间件机制被称为<code>洋葱模型</code>，其核心思想是将HTTP请求和响应对象一次传递给各个中间件函数，形成一条类似于洋葱的管道，最终返回响应结果。<br />具体来说，Koa 洋葱模型的处理流程可以大致分为四个阶段：</p>
<ol>
<li><code>请求阶段</code>：从外到内依次执行请求相关的中间件，例如解析请求体、设置响应头等操作。</li>
<li><code>业务阶段</code>：执行业务逻辑相关的中间件，例如处理授权、验证身份、路由分发等操作。</li>
<li><code>响应阶段</code>：从内到外依次执行响应相关的中间件，例如格式化响应数据、设置响应头等操作。</li>
<li><code>错误处理阶段</code>：如果在前面的中间件过程中出现了错误，则会跳过后续中间件并交给错误处理中间件来处理异常情况。</li>
</ol>
<p>在这个过程中，每个中间件都可以根据需要对请求和响应对象进行修改、扩展、封装等操作，并将控制权传递给下一个中间件，形成了一条流水线式的处理模式。这种设计可以大大提高代码的复用和可读性，同时也方便了对程序行为进行监控、调试和优化。<br />总之，Koa 洋葱模型是一种基于中间件机制的 Web 应用程序开发方法，它通过将请求和响应对象依次传递给各个中间件函数，实现了<code>业务逻辑的分层和复用</code>，并且具有灵活、可扩展和高效的特点。</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>js知识体系（一）</title>
    <url>/2023/08/12/js%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="考察很多"><a href="#考察很多" class="headerlink" title="考察很多"></a><label style="color:rgb(223, 42, 63)">考察很多</label></h3><h4 id="JS的数据类型，它们的区别？"><a href="#JS的数据类型，它们的区别？" class="headerlink" title="JS的数据类型，它们的区别？"></a><label style="color:rgb(223, 42, 63)">JS的数据类型，它们的区别？</label></h4><p>js共有8种数据类型，分别是Undefined,Null,Boolean,Number,String,Object,Symbol,Bignt。<br>其中Symbol,Bight是ES6中新增的数据类型：</p>
<ul>
<li>Symbol代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>Bigint 是一种数字类型的数据，它可以表示任意精度格式的证书，使用BigInt可以安全地存储和操作大整数，即使这个数已经超出Number能够表示地安全整数范围。</li>
</ul>
<p>这些数据乐意分为原始数据类型和引用数据类型：</p>
<ul>
<li>栈：原始数据类型直接存储在栈中地简单数据段，占据空间小，大小固定，属于被频繁使用数据，所以放入栈中存储。</li>
<li>堆：引用数据类型（对象，数组，函数）</li>
</ul>
<p>两种类型地区别在于<strong>存储位置的不同：</strong></p>
<ul>
<li><code>原始数据类型</code>直接<code>存储在栈中</code>的简单数据段，占据空间小，大小固定 ，属于被频繁使用数据，所以放入栈中存储；</li>
<li><code>引用数据类型</code>存储在<code>堆中</code>的对象，占据空间大，大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其中在栈中地额地址，武德地址后从堆中获得实体。</li>
</ul>
<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>
<ul>
<li>在数据结构中，<code>栈</code>中数据的存取方式为<code>先进先出</code></li>
<li><code>堆</code>是一个优先队列，是按<code>优先级</code>来进行排序的，优先级可以按照大小来规定。</li>
</ul>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ul>
<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>堆区内存一般由开饭分配释放，若开发者不是释放，程序结束时可能由垃圾回收机制回收。</li>
</ul>
<h4 id="数据类型检测的方式有哪些？"><a href="#数据类型检测的方式有哪些？" class="headerlink" title="数据类型检测的方式有哪些？"></a><label style="color:rgb(223, 42, 63)">数据类型检测的方式有哪些？</label></h4><pre><code>  1. typeof:其中数组，对象，null都会被判断为object，其它判断都正确。
  2. instanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>)<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>)<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//以检测字符串类型false解释原理</span></span><br><span class="line"><span class="comment">//上方放回false，是因为&#x27;str&#x27;本身不是任何一个类的实例，要想检测的结果为false,只能通过new一个String达到目标</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str <span class="keyword">instanceof</span> <span class="title class_">String</span>)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//通过typeof str 检测到str返回的仍是string并不是Object.</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> object);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>从上可以看出instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性</p>
<pre><code>  3. constructor
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>   constructor 有两个作用，一是判断数据的类型，二是对象实例通过constrcutor对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<pre><code>  4. Object.prototype.toString.call()
</code></pre>
<p><strong>Object.prototype.toString.call()</strong> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>([]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure>

<p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？<br>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p>
<h4 id="null与undefined的区别"><a href="#null与undefined的区别" class="headerlink" title="null与undefined的区别"></a><label style="color:rgb(223, 42, 63)">null与undefined的区别</label></h4><p>首先Undefined和Null都是基本数据类型，这两个基本数据类型分别都只有一个值，就是undefined和null。<br>undefined代表的含义是未定义，null代表的含义是空对象。一般变量声明了但还没有定义的时候就会返回undefined,null主要用于赋值给一些可能返回对象的变量，作为初始化。<br>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<h4 id="instanceof操作符的实现原理及实现。"><a href="#instanceof操作符的实现原理及实现。" class="headerlink" title="instanceof操作符的实现原理及实现。"></a><label style="color:rgb(223, 42, 63)">instanceof操作符的实现原理及实现。</label></h4><p>instanceof 运算符用于判断构造函数的prototype属性是否出现在对象原型链中的任何位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line">  <span class="comment">//获取对象的原型</span></span><br><span class="line">  <span class="keyword">let</span> proto=object.<span class="title function_">getPrototypeOf</span>(left)</span><br><span class="line">  <span class="comment">//获取构造函数的prototyped对象</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="comment">//判断构造函数的prototype对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!proto) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span>(proto === prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-is-与比较操作符”-”-”-”的区别？"><a href="#Object-is-与比较操作符”-”-”-”的区别？" class="headerlink" title="Object.is()与比较操作符”&#x3D;&#x3D;”,”&#x3D;&#x3D;&#x3D;”的区别？"></a><label style="color:rgb(223, 42, 63)">Object.is()与比较操作符”&#x3D;&#x3D;”,”&#x3D;&#x3D;&#x3D;”的区别？</label></h4><ul>
<li>使用&#x3D;&#x3D;进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后在进行比较。</li>
<li>使用&#x3D;&#x3D;&#x3D;进行相等判断时，如果两边的类型不一致，则不会做强制类型转换，直接返回false</li>
<li>使用Object.js来进行相等判断时，一般情况下和&#x3D;&#x3D;&#x3D;的判断相同，它处理了一些特殊的情况，比如：-0和+0不再相等，两个NaN是相等的。</li>
</ul>
<hr>
<h3 id="考察较多"><a href="#考察较多" class="headerlink" title="考察较多 "></a><label style="color:rgb(236, 170, 4)">考察较多 </label></h3><h5 id="isNaN和Number-isNaN函数的区别？"><a href="#isNaN和Number-isNaN函数的区别？" class="headerlink" title="isNaN和Number.isNaN函数的区别？"></a><label style="color:rgb(236, 170, 4)">isNaN和Number.isNaN函数的区别？</label></h5><ul>
<li>函数isNaN接受参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的值都会返回true,因此非数字值传入也会返回true,会影响NaN的判断。</li>
<li>函数Number.isNaN会首先判断传入参数是否为数字，如果是数字再继续判断是否为NaN，不会进行数据类型的转换，这种方法对NaN的判断更加准确。</li>
</ul>
<h5 id="浅谈浅拷贝和深拷贝"><a href="#浅谈浅拷贝和深拷贝" class="headerlink" title="浅谈浅拷贝和深拷贝 "></a><label style="color:rgb(236, 170, 4)">浅谈浅拷贝和深拷贝 </label></h5><p>在js中浅拷贝和深拷贝是两种不同的对象拷贝方式。<br>浅拷贝是指创建一个新对象，然后将原始对象的属性值复制到新对象中。新对象和原始对象共享相同的引用类型属性（如对象，数组等），也就是说，如果修改新对象的引用类型属性，原始对象也会受到影响。<br>深拷贝是指创建一个新对象，然后递归的将原始对象的所有属性值复制到新对象中。新对象和原始对象不共享引用类型属性，也就是说，修改新对象的引用类型属性不会影响原始对象。<br>区别：</p>
<ul>
<li>浅拷贝只复制对象的引用，而不是复制引用指向的值本身；深拷贝则会递归地复制对象及引用的值。</li>
<li>浅拷贝创建的新对象和原始对象共享引用类型属性，而深拷贝创建的新对象和原始对象不共享引用类型属性。</li>
</ul>
<p>js深拷贝与浅拷贝是什么？区别又是什么<br>在 JavaScript 中，深拷贝和浅拷贝是两种不同的对象拷贝方式。<br>浅拷贝是指创建一个新对象，然后将原始对象的属性值复制到新对象中。新对象和原始对象共享相同的引用类型属性（如对象、数组等），也就是说，如果修改新对象的引用类型属性，原始对象也会受到影响。<br>深拷贝是指创建一个新对象，然后递归地将原始对象的所有属性值复制到新对象中。新对象和原始对象不共享引用类型属性，也就是说，修改新对象的引用类型属性不会影响原始对象。<br>区别：</p>
<ul>
<li>浅拷贝只复制对象的引用，而不复制引用指向的值本身；深拷贝则会递归地复制对象及其引用的值。</li>
<li>浅拷贝创建的新对象和原始对象共享引用类型属性，而深拷贝创建的新对象和原始对象不共享引用类型属性。</li>
</ul>
<p>两种拷贝的实例<br>以下是两种拷贝方式的实例：</p>
<ol>
<li><strong>浅拷贝示例：</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">hobbies</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;painting&#x27;</span>]&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">obj2.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;running&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;name: &#x27;Alice&#x27;, age: 25, hobbies: [&#x27;reading&#x27;, &#x27;painting&#x27;, &#x27;running&#x27;]&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;name: &#x27;Bob&#x27;, age: 25, hobbies: [&#x27;reading&#x27;, &#x27;painting&#x27;, &#x27;running&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，使用Object.assign()进行浅拷贝。修改了obj2的属性值后，obj1的hobbies属性也被修改了，因为它们共享相同的引用类型属性。<br><strong>2.深拷贝示例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">hobbies</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;painting&#x27;</span>]&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">obj2.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;running&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;name: &#x27;Alice&#x27;, age: 25, hobbies: [&#x27;reading&#x27;, &#x27;painting&#x27;]&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;name: &#x27;Bob&#x27;, age: 25, hobbies: [&#x27;reading&#x27;, &#x27;painting&#x27;, &#x27;running&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，使用JSON.stringify()将obj1转换为字符串，然后使用JSON.parse()将其转换回对象，从而实现深拷贝。修改了obj2的属性值后，obj1的hobbies属性没有被修改，因为它们不共享引用类型属性。</p>
<hr>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="考察很多-1"><a href="#考察很多-1" class="headerlink" title="考察很多"></a><label style="color:rgb(223, 42, 63)">考察很多</label></h3><h4 id="let-const-var的区别"><a href="#let-const-var的区别" class="headerlink" title="let,const,var的区别"></a><label style="color:rgb(223, 42, 63)">let,const,var的区别</label></h4><ol>
<li><strong>块级作用域</strong>：块级作用域由{  }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域可以解决ES5中的两个问题：<ol>
<li>内层变量肯能覆盖外层变量</li>
<li>用来计数的循环变量泄漏为全局变量</li>
</ol>
</li>
<li><strong>变量提升</strong>：var存在变量提升，let和const不存在变量提升 ，即只能在变量声明之后使用否则会报错</li>
<li><strong>给全局添加属性</strong>：浏览器的全局对象是window，Node的全局对象是global。var声明的变量可以为全局变量，并且会将改变量添加为全局对象的属性，但是let和const不会。</li>
<li><strong>重复声明</strong>：var声明变量是，可以重复声明变量，后声明的同名变量会覆盖之前声明的。而const和let不允许重复声明变量。</li>
<li><strong>暂时性死区</strong>：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。</li>
<li><strong>初始值设置</strong>：在变量声明时，var,let可以不用设置初始值，但是const必须设置初始值。</li>
<li><strong>指针指向</strong>： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</li>
</ol>
<p><img src="/img/study/let.png" alt="image.png"></p>
<h4 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a><label style="color:rgb(223, 42, 63)">箭头函数与普通函数的区别</label></h4><ol>
<li><strong>箭头函数比普通函数更加简洁</strong><ol>
<li>如果没有参数，直接协议可空括号即可</li>
<li>如果只有一个参数，可以省去参数的括号</li>
<li>如果由多个参数，用逗号分割</li>
<li>如果函数体返回值只有一句，可以省略大括号</li>
<li>如果函数不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常用的就是调用函数：</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">void</span> <span class="title function_">doesNotReturn</span>();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>箭头函数没有自己的this</strong></li>
</ol>
<p>箭头函数不会创建自己的this,所以它没有自己的this,它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它定义时已经确定了，之后不会改变。</p>
<ol start="3">
<li><strong>箭头函数继承来的this指向永远不会改变</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">a</span>();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.<span class="title function_">b</span>();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">a</span>()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">b</span>()  <span class="comment">// Uncaught TypeError: obj.b is not a constructor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>
<ol start="4">
<li><strong>call(),apply()，bind()等方法不能改变箭头函数中的this指向</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fun1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fun1</span>();                     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">apply</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);    <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.<span class="title function_">bind</span>(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;)();   <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>箭头函数不能作为构造函数使用</strong></li>
</ol>
<p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>
<ol start="6">
<li><strong>箭头函数没有自己的arguments</strong></li>
</ol>
<p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p>
<ol start="7">
<li><strong>箭头函数没有prototype</strong></li>
<li><strong>箭头函数不能用作Generatir函数，不能使用yeild关键字</strong></li>
</ol>
<h3 id="考察较多-1"><a href="#考察较多-1" class="headerlink" title="考察较多"></a><label style="color:rgb(236, 170, 4)">考察较多</label></h3><h4 id="const对象的属性可以修改吗"><a href="#const对象的属性可以修改吗" class="headerlink" title="const对象的属性可以修改吗"></a><label style="color:rgb(236, 170, 4)">const对象的属性可以修改吗</label></h4><p>const保证的不是变量的值不能改变，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值，字符串，布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。<br>但是对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针式固定不变的，至于它指向的数据结构式不可变的，就完全不能控制了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a为引用类型数据时：</span></span><br><span class="line"><span class="keyword">const</span> a=[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>]</span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&quot;4&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a为基本数据类型时</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span></span><br><span class="line">a=<span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//报错，error: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h4 id="如果new一个箭头函数会产生什么结果？"><a href="#如果new一个箭头函数会产生什么结果？" class="headerlink" title="如果new一个箭头函数会产生什么结果？"></a><label style="color:rgb(236, 170, 4)">如果new一个箭头函数会产生什么结果？</label></h4><p>箭头函数是ES6中新提出来的，它没有自己的this指向，更不可以使用argyments参数，所以并不能够new一个箭头函数。<br>new操作符的实现步骤如下：</p>
<ul>
<li>创建一个对象</li>
<li>将构造函数的租用与赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li>
<li>指向构造函数中的代码，构造函数中的this指向对象（也就是为这个对象添加方法和属性）</li>
<li>返回新的对象</li>
</ul>
<p>因此，由于箭头函数不能执行第二步和第三步所以并不能new一个箭头函数。</p>
<h4 id="ES6中字符串的处理"><a href="#ES6中字符串的处理" class="headerlink" title="ES6中字符串的处理"></a><label style="color:rgb(236, 170, 4)">ES6中字符串的处理</label></h4><p>随着ES6的发布 ，可以发现它除了新增了模板语法外（例如：<code>aka$&#123;a&#125;uio</code>）外还新增了一系列的字符串方法用于提升开发效率。<br>（1）存在性判定：在过去判断一个字符&#x2F;字符串是否在某字符串中时，只能用indexOf&gt;-1来判断。现在ES6提供了三个方法：includes,startsWith,endWith，它们都会返回一个布尔值来告诉你是否存在。</p>
<ul>
<li>includes：判断字符串与字符的包含关系：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> son = <span class="string">&#x27;haha&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.<span class="title function_">includes</span>(son) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>startsWith：判断字符串是否以某个&#x2F;某串字符开头：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.<span class="title function_">startsWith</span>(<span class="string">&#x27;haha&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">father.<span class="title function_">startsWith</span>(<span class="string">&#x27;xixi&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>endsWith：判断字符串是否以某个&#x2F;某串字符结尾：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">  father.<span class="title function_">endsWith</span>(<span class="string">&#x27;hehe&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（2）自动重复：可以使用repeat方法来使同一个字符串输出多次（被连续复制）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceCode = <span class="string">&#x27;repeat for 3 times;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> repeated = sourceCode.<span class="title function_">repeat</span>(<span class="number">3</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(repeated) <span class="comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习(二) — 服务器开发配置</title>
    <url>/2023/08/10/webpack%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="webpack服务器开发配置"><a href="#webpack服务器开发配置" class="headerlink" title="webpack服务器开发配置"></a>webpack服务器开发配置</h3><p><strong>为什么要搭建webpack服务器？</strong><br><img src="/img/study/server.png" alt="image.png"></p>
<h4 id="本地服务器server"><a href="#本地服务器server" class="headerlink" title="本地服务器server"></a>本地服务器server</h4><p>搭建本地服务器常用上面的第二种方式即 <code>webpack-dev-server </code></p>
<p> 首先先安装 <code>webpack-dev-server</code> </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">webpack-dev-server</span> <span class="string">-D</span></span><br></pre></td></tr></table></figure>

<p> 安装成功之后再<code>package.json</code>中加入 <code>&quot;serve&quot;:&quot;webpack serve&quot;</code> ,用于执行 <code>npm run serve</code> 命令开启本地服务器</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack serve&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ts-check&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc --noEmit&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ts-check-watch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc --noEmit --watch&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>开启服务器成功<img src="/img/study/server2.png" alt="image.png"><br>并且当再次在文件中修改代码的时候服务器会自动编译并刷新页面，展示最新编译之后的效果。这将会增加开发效率。<br><img src="/img/study/server3.png" alt="image.png"></p>
<h4 id="server的静态资源"><a href="#server的静态资源" class="headerlink" title="server的静态资源"></a>server的静态资源</h4><p>如何引入使用静态资源？<br><img src="/img/study/server4.png" alt="image.png"></p>
<h4 id="server的其他配置"><a href="#server的其他配置" class="headerlink" title="server的其他配置"></a>server的其他配置</h4><p><img src="/img/study/host.png" alt="image.png"><br><img src="/img/study/port.png" alt="image.png"></p>
<h4 id="server的proxy代理-也可以是跨域问题的解决方案"><a href="#server的proxy代理-也可以是跨域问题的解决方案" class="headerlink" title="server的proxy代理(也可以是跨域问题的解决方案)"></a>server的proxy代理(也可以是跨域问题的解决方案)</h4><p>当webpack服务器和api接口的的服务器在使用时是资源产生了跨域可以借助<code>proxy代理</code>（<code>node项目不存在跨域</code>，因为它们本身相当于在一台服务器上进行所以不会存在跨域）进行解决。</p>
<ul>
<li>安装axios   <code>npm install axios</code></li>
<li>在webpack.config.js中配置proxy代理相关代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">static</span>: [<span class="string">&quot;public&quot;</span>],</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">//接口路径前面的公共部分，让其在接口调用的js文件中用api代替</span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">&quot;http://localhost:9000&quot;</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">        <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用接口的文件中更改接口路径的样式，例如将接口前面（包括端口号）的公共部分用api代替</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送网络请求：   安装axios：  npm install axios</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;/api/users/list&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/study/proxy.png" alt="image.png"></p>
<h4 id="changeOrigin作用"><a href="#changeOrigin作用" class="headerlink" title="changeOrigin作用"></a>changeOrigin作用</h4><p><img src="/img/study/change1.png" alt="image.png"><br>当值为true时，host的端口号瑜api接口的一样<br><img src="/img/study/change2.png" alt="image.png"><br>如果不写changeOrigin则host的值与webpack本地服务器的端口号一致</p>
<h4 id="historyApiFallback"><a href="#historyApiFallback" class="headerlink" title="historyApiFallback"></a>historyApiFallback</h4><p><img src="/img/study/history.png" alt="image.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">static</span>: [<span class="string">&quot;public&quot;</span>],</span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&quot;http://localhost:9000&quot;</span>,</span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">        <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>经过上方配置后当请求一个不存在的页面（如localhost:8080&#x2F;about对应的页面不存在），则不会报错会展示localhost:8080页面</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习(一) — 基础配置</title>
    <url>/2023/08/08/webpack%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="一-了解什么是Webpack？Webpack的作用是什么？"><a href="#一-了解什么是Webpack？Webpack的作用是什么？" class="headerlink" title="一.了解什么是Webpack？Webpack的作用是什么？"></a>一.了解什么是Webpack？Webpack的作用是什么？</h4><p><code>Webpack</code>是一种端资源构建工具，一个<code>静态模块打包器</code>。<br>Webpack的作用就是将在node中写好的代码(后端)解析为在浏览器(前端)可以运行的代码，<code>提高了项目效率和可维护性</code>。</p>
<h4 id="二-Webpack的5个核心概念"><a href="#二-Webpack的5个核心概念" class="headerlink" title="二.Webpack的5个核心概念"></a>二.Webpack的5个核心概念</h4><p><code>1. entry入口</code></p>
<p>入口指示Webpack以哪个入口文件开始打包，分析构建内部依赖图</p>
<p><code>2. output输出</code></p>
<p>输出指示Webpack打包后的资源bundlex输出到哪里，以及如何命名</p>
<p><code>3. loader(翻译官的作用)</code></p>
<p>loader可以让webpack能够处理哪些非js文件（webpack自身只理解js,json,线wenpack5可以处理图片资源）</p>
<p><code>4. plugins</code></p>
<p>插件plugins可以用于执行范围更广的任务。插件的范围包括：从打包优化和压缩，一直到重新定义环境中的变量。</p>
<p><code>5. mode</code></p>
<p>模块知识Webpack使用相应模式的配置。<br><img src="/img/study/webpack1.png" alt="image.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  webpack.config.js是webpack的配置文件</span></span><br><span class="line"><span class="comment">  作用：告诉webpack干哪些活（运行webpack指令时，会加载里面的配置）</span></span><br><span class="line"><span class="comment">  所有的构建工具都是基于nodejs平台运行的，模块化默认采用commonjs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出路径 __dirname是nodejs的变量，代表当前文件webpack.js目录的绝对路径02打包样式资源</span></span><br><span class="line">    <span class="comment">// 输出到build目录下去</span></span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader的配置（1.下载2.使用）</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// test:使用正则匹配文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use:使用哪些loader进行处理，执行顺序是倒序依次执行，比如会先使用css-loader再使用style-loader</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// style-loader会创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// css-loader会将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将less文件编译成css文件,需要安装less和less-loader</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 处理图片资源【webpack5会自动处理图片资源 ！！加上以下配置反而图片显示不出来，webpack4可以用以下配置】</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   test: /\.(jpg|png|gif)$/,</span></span><br><span class="line">      <span class="comment">//   // 使用多个loader时可以用use:[],如果只使用一个loader可以直接写loader:‘xxx’</span></span><br><span class="line">      <span class="comment">//   // url-loader依赖file-loader，所以需要下载两个包</span></span><br><span class="line">      <span class="comment">//   loader: &#x27;url-loader&#x27;,</span></span><br><span class="line">      <span class="comment">//   // 图片配置信息</span></span><br><span class="line">      <span class="comment">//   options: &#123;</span></span><br><span class="line">      <span class="comment">//     // 一般会对小图片进行base64处理，这里是当图片小于8kb时，就会被base64处理成字符串</span></span><br><span class="line">      <span class="comment">//     // 优点：减少请求数量（减轻服务器压力）</span></span><br><span class="line">      <span class="comment">//     // 缺点：图片体积会变大导致问价请求速度变慢</span></span><br><span class="line">      <span class="comment">//     limit: 10 * 1024, //根据项目情况来定，假如项目中小图片是9kb,难么这里可以设置10*1024</span></span><br><span class="line">      <span class="comment">//     // 在webpack4中ulr-loader默认使用es6模块化解析，而html-loader引入图片是commonjs</span></span><br><span class="line">      <span class="comment">//     // 解析时会出现问题：src内容会变为[object module]</span></span><br><span class="line">      <span class="comment">//     // 解决办法：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class="line">      <span class="comment">//     esModule: false,</span></span><br><span class="line">      <span class="comment">//     // 打包后的图片的名称是hash值，字符比较长，可以自定义命名</span></span><br><span class="line">      <span class="comment">//     // 意思为：取hash值的前10位，[ext]是指取文件原来扩展名</span></span><br><span class="line">      <span class="comment">//     name: &#x27;[hash:10].[ext]&#x27;</span></span><br><span class="line">      <span class="comment">//   &#125;</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">      <span class="comment">// html-loader处理html中的img图片资源（负责引入img标签，然后交由url-loader进行解析处理）</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 打包其他资源(除了html/css/js以外的资源)</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// exclude:排除html，css,js资源的其他资源都适用file-loader（比如字体图标iconfont）</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(html|css|js)$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件（1.下载2.引入3.使用）</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin插件会打包html文件</span></span><br><span class="line">    <span class="comment">// 功能：会默认创建一个空的html，自动引入打包后输出的所有资源（js/css）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// template模版：意味复制./src/index.html文件，并自动引入打包后输出的所有资源</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三-搭建webpack的基础配置"><a href="#三-搭建webpack的基础配置" class="headerlink" title="三.搭建webpack的基础配置"></a>三.搭建webpack的基础配置</h4><ol>
<li>安装依赖：———–  <code>npm init</code></li>
<li>安装webpack<ol>
<li>自从有了webpack4之后如果想要使用webpack必须要安装webpack-cli，-D代表实在开发环境中</li>
<li>安装<code>npm install webpack webpack-cli -D</code></li>
</ol>
</li>
<li>创建src文件夹，里面创建入口文件main.js编辑需要的内容</li>
<li>利用webpack对内容进行打包<ol>
<li>在最外层(src的同级目录)创建webpack.config.js文件（文件名称不可更改）</li>
<li>webpack.config.js文件内容：</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入path 导入node.js 中专门操作路径模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用node.js 中的导出语法，向外导出 一个 webpack配置对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">export</span> = &#123;</span><br><span class="line">  <span class="comment">//入口文件</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">//出口文件</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">//__dirname:当前目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./build&quot;</span>),</span><br><span class="line">    <span class="comment">//打包生成的文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;il</span><br></pre></td></tr></table></figure>

<pre><code>  3. 因为初始配置的时候已经安装了webpack，这时你可以在node-modules/.bin文件夹中发现webpack文件夹所以这个时候再次利用webpack只需要在控制台输入`npx webpack`指令就会去bin文件中寻找webpack.
  4. 注意上方代码可能会报错：Module not found: Error: Can&#39;t resolve &#39;./src&#39; in &#39;D:\Study\Webpack\01-source-map&#39;这是因为新版的webpack比旧版的更加严格，他一般认为index.html或index.js是入口文件，把main改成index即可。
</code></pre>
<h4 id="四-source-map（编译后源文件的映射即编译后的代码）"><a href="#四-source-map（编译后源文件的映射即编译后的代码）" class="headerlink" title="四.source-map（编译后源文件的映射即编译后的代码）"></a>四.source-map（编译后源文件的映射即编译后的代码）</h4><h5 id="认识source-map"><a href="#认识source-map" class="headerlink" title="认识source-map"></a>认识source-map</h5><pre><code>     a.代码通常运行在浏览器上时，是通过**打包压缩**的：
</code></pre>
<ul>
<li>这也就表明了真实跑在浏览器上的代码和我们编写的代码是有差异的；</li>
<li>比如ES6的代码可能被转化成ES5</li>
<li>比如对应的代码行号，列号在经过编译后肯定不会一致</li>
<li>比如代码进行丑化压缩时，会将编码名称等修改</li>
<li>比如我们使用了TypeScript等方式编写的代码，最终回转换成JS</li>
</ul>
<p>b.但是，当代码报错需要调试时，调试转换后的代码时很困难的。<br>c.那么如何可以<strong>调试这种转换后不一致的代码</strong>呢？答案是<strong>source-map</strong></p>
<ul>
<li>source-map是从已转换的代码映射到原始的源文件</li>
<li>使浏览器可以重构原始源并在调试器中显示重建的原始源</li>
</ul>
<h5 id="如何使用source-map"><a href="#如何使用source-map" class="headerlink" title="如何使用source-map?"></a>如何使用source-map?</h5><p>可以分为以下两个步骤;</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 第一步：根据源文件，生成source-map文件，webpack在打包的时候，可以配置生成source-map(即在配置文件中加入;devtool: ‘选定的值’)。配置代码如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>); <span class="comment">//引入path</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  <span class="comment">//项目入口文件配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="comment">//项目出口文件配置</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;build&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> 第二步：在转换后的代码，最后添加一个注释，它指向sourcemap;  一般在转换后的代码中会自动生成：如下代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//即上方提到的注释bundle.js文件名字</span></span><br><span class="line"><span class="comment">//# sourceMappingURL=common.bundle.js.map</span></span><br></pre></td></tr></table></figure>

<p>source-map的好处：<br>浏览器会根据我们的注释查找相应的source-map,并且根据source-map还原我们的代码，方便调试。<br>在Chrome中打开控制台，选择设置，按照如下方式打开source-map:<br><img src="/img/study/sourceMap.png" alt="image.png"></p>
<h5 id="生成source-map文件"><a href="#生成source-map文件" class="headerlink" title="生成source-map文件"></a>生成source-map文件</h5><ul>
<li><strong>如何在使用webpack打包的时候，生成对应的source-map?</strong><ul>
<li>webpack为我们提供了非常多的选项（目前是26个），来处理source-map</li>
<li>官方文档：<a href="https://www.webpackjs.com/configuration/devtool/">https://www.webpackjs.com/configuration/devtool/</a></li>
<li>选择不同的值，生成的source-map会稍微有差异，打包过程也会有差异，可能根据不同的情况进行选择；</li>
</ul>
</li>
<li><strong>下面几个值不会生成source-map</strong><ul>
<li>false：不适用source-map，也就是没有任何和source-map相关的内容</li>
<li>none：production模式下的默认值（什么值都不写），不生成source-map。</li>
<li>eval：development模式下的默认值，不生成source-map<ul>
<li>但是它会在eval执行的代码中，添加&#x2F;&#x2F;#sourceURL&#x3D;</li>
<li>它会被浏览器在执行时解析，并且调试面板中生成对应的一些文件目录，方便我们调试</li>
</ul>
</li>
</ul>
</li>
<li><strong>生成source-map</strong><ul>
<li>source-map:生成一个独立的source-map文件，并在bundle文件中有一个注释指向source-map文件</li>
</ul>
</li>
</ul>
<p>其他类型的值了解即可</p>
<h4 id="五-深入解析Babel-polyfill"><a href="#五-深入解析Babel-polyfill" class="headerlink" title="五.深入解析Babel-polyfill"></a>五.深入解析Babel-polyfill</h4><p>什么是Babel？</p>
<ul>
<li>Babel是一个工具链，主要用于旧浏览器或者环境中将ECMAScript 2015+代码转换为向后兼容版本的js</li>
<li>包括：语法转换，源代码转换，Polyfil实现目标环境缺少的功能等。</li>
</ul>
<h5 id="Babel命令执行"><a href="#Babel命令执行" class="headerlink" title="Babel命令执行"></a>Babel命令执行</h5><ul>
<li>babel本身可以作为一个独立的工具（和postcss一样），不和webpack等构建工具配置单独使用。</li>
<li>如果希望在命令行尝试使用babel，需要安装如下库：<ul>
<li><code>@babel/core</code>：babel的核心代码，<code>必须安装</code></li>
<li>@babel&#x2F;cli：可以让我们在命令行中使用babel;</li>
</ul>
</li>
</ul>
<p>安装指令：<code>npm install @babel/cli @babel/core</code></p>
<ul>
<li>使用babel处理所写的源代码：<ul>
<li>src：源文件的目录</li>
<li>–out-dir：指定要输出的文件夹dist;</li>
</ul>
</li>
</ul>
<p>处理指令：<code>npx babel src --out-dir dist</code></p>
<ul>
<li>插件安装：<ul>
<li>如果需要转换箭头函数，则要安装使用箭头函数转换相关的插件：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装插件指令：npm install @babel/plugin-transform-arrow-functions -D</span><br></pre></td></tr></table></figure>

<p>转换源代码（并转换里面的箭头函数）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx babel ./src --out-dir ./build --plugins=@babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要转换块级作用域（即将const，let转换成var），则要安装转换块级作用域相关的插件：</li>
</ul>
<p>安装插件指令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install @babel/plugin-transform-block-scoping -D</span><br></pre></td></tr></table></figure>

<p>转换源代码（并转换里面的箭头函数和块级作用域）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx babel ./src --out-dir ./build --plugins=@babel/plugin-transform-block-scoping,@babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Babel的预设preset</strong></p>
<ul>
<li>当转换的内容过多的时候，一个个设置比较麻烦，因此可以使用预设（preset）减少步骤</li>
<li>安装@babel&#x2F;preset-env预设：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install @babel/preset-env -D</span><br></pre></td></tr></table></figure>

<ul>
<li>执行下方命令生成对应文件：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx babel ./src --out-dir ./bulid --presets=@babel/preset-env</span><br></pre></td></tr></table></figure>

<h5 id="Babel的底层原理-较为重要"><a href="#Babel的底层原理-较为重要" class="headerlink" title="Babel的底层原理(较为重要)"></a>Babel的底层原理(较为重要)</h5><p>Babel拥有编译器的工作流程：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 解析阶段（Parsing）</li>
<li><input checked="" disabled="" type="checkbox"> 转换阶段（Transfromation)</li>
<li><input checked="" disabled="" type="checkbox"> 生成阶段（Code Generation）</li>
</ul>
<p><img src="/img/study/Babel.png" alt="image.png"></p>
<h5 id="浏览器兼容性配置"><a href="#浏览器兼容性配置" class="headerlink" title="浏览器兼容性配置"></a>浏览器兼容性配置</h5><p>要想实现浏览器的兼容性需要借助Browserslist<br>Browserslist是什么？Browserslist是一个在不同的前端工具之间，共享目标浏览器和Node.js版本的配置</p>
<ul>
<li><input disabled="" type="checkbox"> Autoprefixer</li>
<li><input disabled="" type="checkbox"> Babel</li>
<li><input disabled="" type="checkbox"> postcss-preset-env</li>
<li><input disabled="" type="checkbox"> eslint-plugin-compat</li>
<li><input disabled="" type="checkbox"> stylelint-no-unsupported-broewr-features</li>
<li><input disabled="" type="checkbox"> postcss-normailze</li>
<li><input disabled="" type="checkbox"> obsolete-webpack-plugin</li>
</ul>
<p><img src="/img/study/Bowerslist1.png" alt="image.png"><br><img src="/img/study/Bowerslist2.png" alt="image.png"><br><strong>配置browserlist</strong></p>
<ul>
<li>如何配置browerlist?<ul>
<li>方案一：在package.json中配置</li>
<li>方案二：单独的一个配置文件.browserslistrc</li>
</ul>
</li>
<li>方案一：package.json配置：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;browerslist&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;last 2 version&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;not dead&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;&gt;0.2%&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方案二：.browerslistrc文件:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 0.5%</span><br><span class="line">last 2 version</span><br><span class="line">not dead</span><br></pre></td></tr></table></figure>

<p><img src="/img/study/Browerslist3.png" alt="image.png"><br>根据上方条件找到符合情况的所有浏览器，根据浏览器的特性对需要转换打包的代码进行适当的调整。<br><strong>设置目标浏览器的browserlist</strong><br>最终打包的js文件需要跑在目标浏览器上，那么如何告知babel目标浏览器是什么？</p>
<ul>
<li>方式一：借助browserslist工具</li>
<li>方式二：target属性</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">module<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    rules<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        test<span class="punctuation">:</span> /\.js$/<span class="punctuation">,</span></span><br><span class="line">        use<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          loader<span class="punctuation">:</span> <span class="string">&quot;babel-loader&quot;</span><span class="punctuation">,</span></span><br><span class="line">          options<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            presets<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">[</span><span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">              <span class="comment">//在开发中针对babel的浏览器兼容查询使用browerslist工具，而不是设置target</span></span><br><span class="line">              <span class="comment">//因为browserslist工具，可以在多个前端工具之间进行浏览器兼容性（postcss/babel）</span></span><br><span class="line">              <span class="comment">// targets: &quot;&gt;5%&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果两个同时配置产生的效果：</strong></p>
<ul>
<li>配置的targets属性会覆盖browerslist；</li>
<li>但是在 开发过程中，更推荐通过browerslist来配置，因为类似于postcss工具，也会使用broesersliat，进行统一浏览器的适配。</li>
</ul>
<h5 id="babel的配置文件"><a href="#babel的配置文件" class="headerlink" title="babel的配置文件"></a>babel的配置文件</h5><ul>
<li>与大多数配置文件一样，babel的配置信息也可以单独的放在一个独立的文件中。因此，babel给我们提供了两种配置文件的编号：<ul>
<li>babel.config.json（后缀.json也可以 改成.js,.cjs,.mjs）文件；</li>
<li>.babelrc.json(后缀.json也可以改成.js,.cjs,.mjs,作者直接写成.babelrc)文件</li>
<li>例子：</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相当于以前的webpack.config.js中的options里的内容，将其babel配置单独拿出，比较好管理</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//在开发中针对babel的浏览器兼容查询使用browerslist工具，而不是设置target</span></span><br><span class="line">        <span class="comment">//因为browserslist工具，可以在多个前端工具之间进行浏览器兼容性（postcss/babel）</span></span><br><span class="line">        <span class="comment">// targets: &quot;&gt;5%&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上方两种方式的区别？目前很多项目都采用了多包管理的方式（babel本身，element-plus,umi等）；<ul>
<li>babel.config.json（babel17）：可以直接作用域Monorepos项目的子包，更加推荐；</li>
<li>.babelrc.json：早期使用较多的配置方式，但是对配置Monorepros项目是比较麻烦的；</li>
</ul>
</li>
</ul>
<h5 id="babel和polyfill"><a href="#babel和polyfill" class="headerlink" title="babel和polyfill"></a>babel和polyfill</h5><p><strong>polyfill</strong><br><img src="/img/study/polyfill1.png" alt="image.png"></p>
<ol>
<li>安装可以使用polyfill插件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">core-js</span> <span class="string">regenerator-runtime</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在babel.config.js中进行相关配置</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//相当于以前的webpack.config.js中的options里的内容，将其babel配置单独拿出，比较好管理</span></span><br><span class="line"><span class="string">module.exports</span> <span class="string">=</span> &#123;</span><br><span class="line">  <span class="attr">presets:</span> [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">//在开发中针对babel的浏览器兼容查询使用browerslist工具，而不是设置target</span></span><br><span class="line">        <span class="string">//因为browserslist工具，可以在多个前端工具之间进行浏览器兼容性（postcss/babel）</span></span><br><span class="line">        <span class="string">//</span> <span class="attr">targets:</span> <span class="string">&quot;&gt;5%&quot;</span></span><br><span class="line">        <span class="string">//</span> <span class="attr">corejs:</span> <span class="number">3</span>,</span><br><span class="line">        <span class="string">//false表示不使用polyfill进行填充</span></span><br><span class="line">        <span class="attr">useBuiltIns:</span> <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;<span class="string">;</span></span><br></pre></td></tr></table></figure>

<p>注意：当useBuiltIns为false时，corejs需要注释，否则会在控制台提出如下警告：<br><img src="/img/study/polyfill4.png" alt="image.png"><br><img src="/img/study/polyfill2.png" alt="image.png"><br><img src="/img/study/polyfill3.png" alt="image.png"><br>虽然它有三个值可以设置但是尽量使用usage</p>
<h5 id="React和TS解析"><a href="#React和TS解析" class="headerlink" title="React和TS解析"></a>React和TS解析</h5><p><img src="/img/study/react1.png" alt="image.png"><br><strong>一.如何对React进行打包？</strong></p>
<ol>
<li>首先在src下创建存放react组件的文件夹，在里面写react的jsx形式的组件文件</li>
<li>在入口的index.js中引入react组件并进行编写：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//引入react组件</span></span><br><span class="line"><span class="string">import</span> <span class="string">React</span> <span class="string">from</span> <span class="string">&#x27;react&#x27;</span><span class="string">;</span></span><br><span class="line"><span class="string">import</span> <span class="string">ReactDOM</span>  <span class="string">from</span> <span class="string">&#x27;react-dom/client&#x27;</span><span class="string">;</span></span><br><span class="line"><span class="string">import</span> <span class="string">App</span> <span class="string">from</span> <span class="string">&#x27;./react/App.jsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">//编写react代码</span></span><br><span class="line"><span class="string">//在src的同级目录创建一个index.html文件，并创建一个标签作为存放react组件的容器</span></span><br><span class="line"><span class="string">const</span> <span class="string">root=ReactDOM.createRoot(document.querySelector(&quot;#root&quot;))</span></span><br><span class="line"><span class="string">root.render(&lt;App/&gt;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建react文件前需要先安装react插件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">react</span> <span class="string">react-dom</span>       </span><br></pre></td></tr></table></figure>

<p>因为以前的配置只是关于js的，React作用的html文件并未对其进行打包，所以要进行html打包的配置</p>
<ol start="3">
<li>react所需的html打包的配置</li>
</ol>
<ul>
<li>安装html打包的库</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">html-webpack-plugin</span> <span class="string">-D</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在webpack.config.js文件中配置html打包所需代码，这样以后只需要用<code>npm run build</code>也可以生成html的打包文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//html打包所引入的库</span></span><br><span class="line"><span class="string">const</span> <span class="string">HtmlWebpackPlugin</span> <span class="string">=</span> <span class="string">require(&quot;html-webpack-plugin&quot;);</span></span><br><span class="line"><span class="string">const</span> <span class="string">path</span> <span class="string">=</span> <span class="string">require(&quot;path&quot;);</span> <span class="string">//引入path</span></span><br><span class="line"></span><br><span class="line"><span class="string">module.exports</span> <span class="string">=</span> &#123;</span><br><span class="line">  <span class="attr">mode:</span> <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">devtool:</span> <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">  <span class="string">//项目入口文件配置</span></span><br><span class="line">  <span class="attr">entry:</span> <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="string">//项目出口文件配置</span></span><br><span class="line">  <span class="attr">output:</span> &#123;</span><br><span class="line">    <span class="attr">filename:</span> <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path:</span> <span class="string">path.resolve(__dirname</span>, <span class="string">&quot;build&quot;</span><span class="string">)</span>,</span><br><span class="line">    <span class="string">//</span> <span class="string">重新打包时，先将之前打包得文件夹删除掉</span></span><br><span class="line">    <span class="attr">clean:</span> <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module:</span> &#123;</span><br><span class="line">    <span class="attr">rules:</span> [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test:</span> <span class="string">/\.jsx?$/</span>, <span class="string">//x?:表示0个或者一个x</span></span><br><span class="line">        <span class="attr">use:</span> &#123;</span><br><span class="line">          <span class="attr">loader:</span> <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">          <span class="string">//</span> <span class="attr">options:</span> &#123;</span><br><span class="line">          <span class="string">//</span>   <span class="attr">presets:</span> [</span><br><span class="line">          <span class="string">//</span>     [<span class="string">&quot;@babel/preset-env&quot;</span>,&#123;</span><br><span class="line">          <span class="string">//</span>     <span class="string">//在开发中针对babel的浏览器兼容查询使用browerslist工具，而不是设置target</span></span><br><span class="line">          <span class="string">//</span>     <span class="string">//因为browserslist工具，可以在多个前端工具之间进行浏览器兼容性（postcss/babel）</span></span><br><span class="line">          <span class="string">//</span>     <span class="string">//</span> <span class="attr">targets:</span> <span class="string">&quot;&gt;5%&quot;</span></span><br><span class="line">          <span class="string">//</span>     &#125;]</span><br><span class="line">          <span class="string">//</span>   ],</span><br><span class="line">          <span class="string">//</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">//打包html文件-----------新增的html打包配置</span></span><br><span class="line">  <span class="attr">plugins:</span> [</span><br><span class="line">    <span class="string">new</span> <span class="string">HtmlWebpackPlugin(</span>&#123;</span><br><span class="line">      <span class="attr">template:</span> <span class="string">&quot;./index.html&quot;</span>,</span><br><span class="line">    &#125;<span class="string">)</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;<span class="string">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>因为要转换react代码所以需要安装react的预设：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">@babel/preset-react</span> <span class="string">-D</span></span><br></pre></td></tr></table></figure>

<p>相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//相当于以前的webpack.config.js中的options里的内容，将其babel配置单独拿出，比较好管理</span></span><br><span class="line"><span class="string">module.exports</span> <span class="string">=</span> &#123;</span><br><span class="line">  <span class="attr">presets:</span> [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">//在开发中针对babel的浏览器兼容查询使用browerslist工具，而不是设置target</span></span><br><span class="line">        <span class="string">//因为browserslist工具，可以在多个前端工具之间进行浏览器兼容性（postcss/babel）</span></span><br><span class="line">        <span class="string">//</span> <span class="attr">targets:</span> <span class="string">&quot;&gt;5%&quot;</span></span><br><span class="line">        <span class="string">//</span> <span class="attr">corejs:</span> <span class="number">3</span>,</span><br><span class="line">        <span class="string">//</span> <span class="attr">useBuiltIns:</span> <span class="string">&quot;usage&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">//react转换的预设</span></span><br><span class="line">    [<span class="string">&quot;@babel/preset-react&quot;</span>]</span><br><span class="line">  ],</span><br><span class="line">&#125;<span class="string">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>二.ts编译打包</strong><br><strong>方式一：</strong></p>
<ol>
<li>首先在src下创建存放ts文件的文件夹，在里面写.ts形式的文件</li>
<li>在入口的index.js中引入ts文件并进行编写：</li>
</ol>
<p>例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">import</span> &#123;<span class="string">sum</span>&#125;  <span class="string">from</span> <span class="string">&#x27;./ts/math.ts&#x27;</span></span><br><span class="line"><span class="string">//使用ts代码</span></span><br><span class="line"><span class="string">console.log(sum(20,30));</span></span><br></pre></td></tr></table></figure>

<p>3.转换ts：<br>首先安装ts相关的转换库让其代码在打包时可以转换成js代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">ts-loader</span> <span class="string">-D</span></span><br></pre></td></tr></table></figure>

<p>其次配置ts-loader:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>); <span class="comment">//引入path</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">  <span class="comment">//项目入口文件配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="comment">//项目出口文件配置</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    <span class="comment">// 重新打包时，先将之前打包得文件夹删除掉</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="comment">//可以是引入文件的时候不加文件的后缀名</span></span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.wasm&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.vue&quot;</span>,<span class="string">&#x27;.ts&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>, <span class="comment">//x?:表示0个或者一个x</span></span><br><span class="line">        <span class="attr">use</span>: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//解析ts</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&quot;ts-loader&quot;</span> <span class="comment">//安装ts-loader：npm install ts-loader -D   下一步创建tsconfig文件：tsc --init</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//打包html文件</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后进行打包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p><img src="/img/study/ts1.png" alt="image.png"><br>在下方中安装ts-loader时就会自动安装上方的ts<br><img src="/img/study/ts2.png" alt="image.png"><br>除了可以用上方的方式编译ts文件之外也可以用下面的方式。它主要是借用babel。<br><strong>方式二：</strong><br>1.因为在ts文件中可能含有es语言之类的新语法，浏览器可能不认识，所以需要对其进行补丁。如果单纯的借助上方方式并不能实现，需要在babel对ts进行预设，并且转换。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">formatPrice</span>(<span class="params">priceString: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">//因为下方的ts中使用了es新推出的includes()方法，为了进行正常的使用所以会对其进行补丁和预设</span></span><br><span class="line">  <span class="keyword">if</span> (priceString.<span class="title function_">includes</span>(<span class="string">&quot;$&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.将webpack.config中的use的值设置为”babel-loader”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析ts</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">    <span class="comment">// use: &quot;ts-loader&quot; //安装ts-loader：npm install ts-loader -D   下一步创建tsconfig文件：tsc --init</span></span><br><span class="line">    <span class="comment">//为了方便以后的运行配置，或者如果ts文件中出现了es新出的方法进行补丁建议使用babel-loader</span></span><br><span class="line">    <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.安装ts的预设</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">@babel/preset-typescript</span> <span class="string">-D</span></span><br></pre></td></tr></table></figure>

<p>4.在babel.config.js中配置ts的预设和补丁，进行方法填充</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ts转换的预设</span></span><br><span class="line">[</span><br><span class="line">  (<span class="string">&quot;@babel/preset-typescript&quot;</span>,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">corejs</span>: <span class="number">3</span>,</span><br><span class="line">     <span class="attr">useBuiltIns</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">   &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p><img src="/img/study/ts3.png" alt="image.png"><br><strong>ts-loader与babel-loader的区别：</strong><br><img src="/img/study/ts4.png" alt="image.png"><br>如何在使用Babel的时候也对ts进行实时监听：<br><img src="/img/study/ts5.png" alt="image.png"><br>package.json中的script的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="comment">//检测ts文件的语法是否正确</span></span><br><span class="line">  <span class="string">&quot;ts-check&quot;</span>: <span class="string">&quot;tsc --noEmit&quot;</span>,</span><br><span class="line">    <span class="comment">//相比于上面这个只要在控制台运行npm run ts-check-watch就会进行实时监听，完全正确之后再ctrl+c进行打包操作</span></span><br><span class="line">  <span class="string">&quot;ts-check-watch&quot;</span>: <span class="string">&quot;tsc --noEmit --watch&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试</title>
    <url>/2023/07/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="一-闭包与原型："><a href="#一-闭包与原型：" class="headerlink" title="一.闭包与原型："></a>一.闭包与原型：</h4><h5 id="1-什么是闭包？闭包的用途？"><a href="#1-什么是闭包？闭包的用途？" class="headerlink" title="1.什么是闭包？闭包的用途？"></a>1.什么是闭包？闭包的用途？</h5><p>1）闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<p>2）js中闭包的优点和缺点：</p>
<p>优点：</p>
<pre><code>       1.保护函数内的变量安全
        
       2.在内存中维持一个变量(用的太多就变成了缺点，占内存) ；
        
       1. 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。

       2. 方便调用上下文的局部变量。

       3. 加强封装性，可以达到对变量的保护作用。
</code></pre>
<p>缺点:</p>
<pre><code>      1.常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
    
      2.还有有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。
</code></pre>
<p>闭包的特性:</p>
<pre><code>    1. 函数嵌套函数

    2. 内部函数可以访问外部函数的变量

    3. 参数和变量不会被回收。

    4. 闭包的典型框架应该就是jquery了。
</code></pre>
<h4 id="二-js基础"><a href="#二-js基础" class="headerlink" title="二.js基础"></a>二.js基础</h4><h5 id="1-JS执行上下文"><a href="#1-JS执行上下文" class="headerlink" title="1.JS执行上下文"></a>1.JS执行上下文</h5><ul>
<li>全局执行上下文：这是默认或基本执行上下文。不在任何函数内的代码都属于全局上下问，一个程序中只能由一个全局执行上下文。他要做的有两件事：<ul>
<li>创建一个全局对象，在浏览器中为(<code>window</code>)。</li>
<li>将 <code>this</code> 的值设置为全局对象。</li>
</ul>
</li>
<li>函数执行上下文:每次调用函数时，都会为该函数创建一个全新的执行上下文。每个函数都有自己的执行上下文，但它是在调用函数时创建的，这个上下文可以保护里面的私有变量和外界互不干扰。</li>
<li>Eval执行上下文：在 <code>eval</code> 函数执行代码也会产生一种特殊的执行上下文，但由于我们通常不会使用它，因此就不讨论了。</li>
<li>每当一个函数执行完毕，则这个函数的执行上下文也将从栈中弹出，等到所有函数都运行完毕，要关闭页面的时候，全局上下文也将出栈释放，程序运行结束。如果当前上下文中的某些内容，被当前上下文以外的东西占用，那么当前上下文是不能被释放的，这就是我们熟知的闭包(Closure)。</li>
</ul>
<h5 id="2-const定义的对象属性可以被修改吗？"><a href="#2-const定义的对象属性可以被修改吗？" class="headerlink" title="2.const定义的对象属性可以被修改吗？"></a>2.const定义的对象属性可以被修改吗？</h5><p>答：const定义的对象属性可以被修改，但是const定义即基本能数据类型string,number等，定义之后不能背修改，修改之后会报错。</p>
<p>原因：</p>
<p>const定义中的不变指的时对象的指针不变，因为修改对象那个中的属性并不会让指向对象的指针发生变化，所以指向对象属性可以被修改。</p>
<h5 id="3-数据类型检测的方式有哪些？"><a href="#3-数据类型检测的方式有哪些？" class="headerlink" title="3.数据类型检测的方式有哪些？"></a>3.数据类型检测的方式有哪些？</h5><ul>
<li><p>typeof:其中数组、对象、null都会被判断为object，其他判断都正确。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);              <span class="comment">// object    </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>
</li>
</ul>
<h4 id="4-js为什么要进行变量提升？会导致什么问题？"><a href="#4-js为什么要进行变量提升？会导致什么问题？" class="headerlink" title="4.js为什么要进行变量提升？会导致什么问题？"></a>4.js为什么要进行变量提升？会导致什么问题？</h4><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问而且不会报错。</p>
<p><strong>为什么执行变量提升？</strong></p>
<ul>
<li><p>提高性能：解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间。</p>
</li>
<li><p>容错性更好：声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</p>
<p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p>
</li>
</ul>
<h4 id="三-js提高"><a href="#三-js提高" class="headerlink" title="三.js提高"></a>三.js提高</h4><h5 id="1-简述事件循环："><a href="#1-简述事件循环：" class="headerlink" title="1.简述事件循环："></a>1.简述事件循环：</h5><p>先同步再异步，先微任务再宏任务。</p>
<p>js是一个单线程的。函数执行的过程是将函数执行上下文压入栈中，直到栈中清空，表示这个任务执行结束。为了保证异步的函数按顺序执行，出现了task queue（任务队列）。任务队列的作用是将各种事件或异步的操作进行通知时加入其回调函数。js引擎会不停的从任务队列中取出任务，压入到栈中执行，执行完成后再取下一个任务执行，如此一直到任务队列为空。如果为空，会一直等待新的任务出现。这种不停的等待处理事件的循环称之为事件循环。</p>
<h5 id="2-虚拟dom是什么-原理-优缺点"><a href="#2-虚拟dom是什么-原理-优缺点" class="headerlink" title="2.虚拟dom是什么? 原理? 优缺点?"></a>2.虚拟dom是什么? 原理? 优缺点?</h5><p>虚拟dom：虚拟dom的本质上是js对象或者是对真实DOM的抽象，状态变更时，记录新书和旧树的差异，最后把差异更新在真正的dom中。（定义及原理）</p>
<p>优点：</p>
<ul>
<li>保证性能下限：虚拟DOM可以通过diff算法找出最小差异，然后批量的进行patch，这种操作虽然比不上手动优化，但是比起出包的DOM操作性能要好很多，因此虚拟DOM可以保证性能的下限。</li>
<li>无需手动操作DOM：虚拟DOM的diff和patch都是在一次更新中自动进行的，我们无需手动操作DOM，极大的提高了开发效率。</li>
<li>跨平台：虚拟dom的本质是js对象，而DOM与平台强相关，相比之下虚拟dom可以进行更方便地跨平台操作，例如服务器的渲染，移动端开发等等。</li>
</ul>
<p>缺点：</p>
<p>无法进行极致优化:在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化，比如VScode采用直接手动操作DOM的方式进行极端的性能优</p>
<h4 id="四-vue2"><a href="#四-vue2" class="headerlink" title="四.vue2"></a>四.vue2</h4><h5 id="1-vue双向绑定的原理是什么？"><a href="#1-vue双向绑定的原理是什么？" class="headerlink" title="1.vue双向绑定的原理是什么？"></a>1.vue双向绑定的原理是什么？</h5><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。</p>
<h5 id="2-Computed和Watch的区别"><a href="#2-Computed和Watch的区别" class="headerlink" title="2.Computed和Watch的区别"></a>2.Computed和Watch的区别</h5><p><strong>对于Computed:</strong></p>
<ul>
<li><p>它支持缓存，只有依赖的数据发生了变化，才会重新计算</p>
</li>
<li><p>不支持异步，当Computed中由异步操作时无法监听数据的变化</p>
</li>
<li><p>computed的值默认走缓存，计算属性是基于他们的响应式依赖进行缓存的，</p>
</li>
<li><p>也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</p>
<p>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</p>
<p>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</p>
<p><strong>对于Watch：</strong></p>
<ul>
<li>它不支持缓存，数据变化时，它就会触发相应的操作</li>
<li>支持异步监听</li>
<li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li>
<li>当一个属性发生变化时，就需要执行相应的操作</li>
<li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul>
<li>immediate：组件加载立即触发回调函数</li>
<li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>
</ul>
</li>
</ul>
<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>
<p><strong>总结：</strong></p>
<ul>
<li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li>
<li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>
</ul>
<p><strong>运用场景：</strong></p>
<ul>
<li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li>
<li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
</li>
</ul>
<h5 id="3-vue中的keep-alive的作用是什么？怎么使用？"><a href="#3-vue中的keep-alive的作用是什么？怎么使用？" class="headerlink" title="3.vue中的keep-alive的作用是什么？怎么使用？"></a>3.vue中的keep-alive的作用是什么？怎么使用？</h5><p><strong>概念</strong></p>
<p>keep-alive是Vue的内置组件，当它包括动态组件时，会缓存不活动的组件实例，该组件不会被销毁。</p>
<p><strong>作用</strong></p>
<p>用来缓存组件，避免多次加载相同的组件，减少性能的消耗，提高用户体验</p>
<p><strong>属性</strong></p>
<ul>
<li>include：字符串或正则表达式。只有匹配的组件会被缓存</li>
<li>exclude：字符串或正则表达式。任何匹配的组件都不会被缓存</li>
</ul>
<p><strong>使用场景</strong></p>
<p>比如：有一个列表页面和一个详情页面，那么用户可能会经常执行打开详情 &#x3D;&gt; 返回列表 &#x3D;&gt; 打开详情，那么就可以对列表组件使用进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染页面，从而节省内存开销。</p>
<p><strong>使用方式</strong></p>
<ul>
<li>在App.vue中使用keep-alive组件缓存页面</li>
<li>按条件缓存使用include，excode判断是否存在缓存<ul>
<li>将缓存name作为keep的组件，如果多个可以用逗号分开</li>
<li>将不换存的name为nokeep的组件</li>
<li>还可以使用属性绑定动态判断</li>
</ul>
</li>
<li>在router目录的index.js中<ul>
<li>使用meta:{keepAlive&#x3D;true},表示需要缓存</li>
</ul>
</li>
<li>在App.vue中进行判断</li>
</ul>
<h4 id="五-html"><a href="#五-html" class="headerlink" title="五.html"></a>五.html</h4><h5 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h5><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>
<ul>
<li><strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li>
<li><strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它指向的⽂件时，就会进行下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li>
</ul>
<h5 id="2-HTML5有哪些更新？"><a href="#2-HTML5有哪些更新？" class="headerlink" title="2.HTML5有哪些更新？"></a>2.HTML5有哪些更新？</h5><ul>
<li>语义化标签：如：header–&gt;定义文档的头部，nav,footer,article,section,aside</li>
<li>媒体标签：audio–&gt;音频，video视频，source</li>
<li>数据存储：localStorage、sessionStorage</li>
<li>表单</li>
<li>进度条，度量器</li>
<li>DOM查询操作</li>
<li>Web存储</li>
<li>input标签新增属性：placeholder、autocomplete、autofocus、required </li>
<li>其他：拖放，canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</li>
</ul>
<p><strong>移除的元素有：</strong></p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<h5 id="3-对HTML语义化的理解"><a href="#3-对HTML语义化的理解" class="headerlink" title="3.对HTML语义化的理解"></a>3.对HTML语义化的理解</h5><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p>
<p>语义化的优点如下：</p>
<ul>
<li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<h4 id="六-Ts（TypeScript）"><a href="#六-Ts（TypeScript）" class="headerlink" title="六.Ts（TypeScript）"></a>六.Ts（TypeScript）</h4><p>TS是微软开发的一个开源的编程语言，通过在js的基础上添加静态类型定义构建而成。</p>
<h5 id="1-TS常用类型："><a href="#1-TS常用类型：" class="headerlink" title="1.TS常用类型："></a>1.TS常用类型：</h5><ul>
<li>JS中已有类型<ul>
<li>原始类型：number,string,boolean,null,undefined,symbol</li>
<li>对象类型：object（数组，函数，对象等）</li>
</ul>
</li>
<li>TS新增类型<ul>
<li>联合类型，自定义类型，接口，元组，字面量类型，枚举，void，any等</li>
</ul>
</li>
</ul>
<h5 id="2-ts中type和Interface的异同："><a href="#2-ts中type和Interface的异同：" class="headerlink" title="2.ts中type和Interface的异同："></a>2.ts中type和Interface的异同：</h5><p>type：是类型别名，给一些类型的组合起别名，方便使用，例如<code>type ID = string | number;</code></p>
<p>Interface:是接口。有点像type，可以用来代表一种类型组合，但它的范围更小一些，只能描述对象的结构。</p>
<p>它们写法有一点区别，type 后面需要用 &#x3D; ，interface 后面不需要 &#x3D; ，直接就带上 { 。</p>
<p>&#x3D;&#x3D;type 和 interface 的不同点有：&#x3D;&#x3D;</p>
<ul>
<li><p>type 后面有  &#x3D; ，interface 没有。</p>
</li>
<li><p>type 可以描述任何类型组合，interface 只能描述对象结构。</p>
</li>
<li><p>interface 可以继承自（extends）interface 或对象结构的 type。type 也可以通过  &amp; 做对象结构的继承。</p>
</li>
<li><p>多次声明的同名 ，interface 会进行声明合并，type 则不允许多次声明。</p>
</li>
</ul>
<h4 id="七-css"><a href="#七-css" class="headerlink" title="七.css"></a>七.css</h4><h5 id="1-浮动"><a href="#1-浮动" class="headerlink" title="1.浮动"></a>1.浮动</h5><p><strong>1.为什么使用浮动。</strong><br>很多网页布局效果，标准流是做不到，所以就要是用浮动来完成布局，浮动可以改变排列方式。</p>
<p><strong>2.浮动引起的问题。</strong><br> 父元素高度塌陷，高度无法撑开。<br>与元素同级的非浮动元素会紧随其后(遮盖现象)。<br>如果一个元素浮动，则该元素之前的元素也需要浮动;否则会影响页面显示的结构</p>
<p><strong>3.解决方案(清除浮动）。</strong><br>给父元素固定高度。没有设置浮动时，父元素的高度是height：auto 高度是由子元素撑开的；这个方法的缺点是，因为设置了固定高度，它的维护性是很差的，适用于固定高度布局。<br>在浮动元素增加一个空div元素，设置样式 clear：both  要放在空元素上。缺点：布局添加了毫无意义的标签，如果有大量的使用无意义的div标签那么就造成很大的冗余。<br>为父元素设置 overflow:hidden 。缺点：受限于overflow:hidden的主要功能，如果子元素的尺寸大于父元素，或者子元素中的内容过多，那么多出来的这一部分将不会溢出，也不会显示出来，会直接被hidden起来；因此这个方法不适用于子元素的内容过多；<br>使用伪类 :after 只需要在父元素上添加一个class;类使用after伪元素，在父元素现有内容的末尾添加新的内容。添加的内容是一个display: block; clear: both;的空元素；</p>
<h5 id="4-什么是重绘和重排？它们的区别是什么？"><a href="#4-什么是重绘和重排？它们的区别是什么？" class="headerlink" title="4.什么是重绘和重排？它们的区别是什么？"></a>4.什么是重绘和重排？它们的区别是什么？</h5><p><strong>重绘</strong>：当页面元素样式的改变不影响布局时，浏览器重新对元素进行更新的过程叫做重绘。</p>
<p><strong>重排</strong>：当页面元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程叫做重排也叫做回流。重绘不一定需要重排，重排必然会导致重绘</p>
<p>1、重排：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</p>
<p>1）添加、删除可见的dom</p>
<p>2）元素的位置改变</p>
<p>3）元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）</p>
<p>4）页面渲染初始化</p>
<p>5）浏览器窗口尺寸改变</p>
<p>2、重绘：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<h5 id="4-dom树是怎么生成的？"><a href="#4-dom树是怎么生成的？" class="headerlink" title="4.dom树是怎么生成的？"></a>4.dom树是怎么生成的？</h5><p>页面得渲染流程总得俩说就五步，创建 DOM 树——创建 StyleRules——创建 Render 树——布局Layout（重排）——绘制 Painting（重绘）</p>
<p>第一步，用 HTML 分析器，分析 HTML 元素，构建一颗 DOM 树(标记化和树构建)。</p>
<p>第二步，用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。</p>
<p>第三步，将 DOM 树和样式表，关联起来，构建一颗 Render 树(这一过程又称为 Attachment)。每个 DOM 节点都有attach 方法，接受样式信息，返回一个render对象(又名renderer)。这些 render 对象最终会被构建成一颗 Render 树。</p>
<p>第四步，有了 Render 树，浏览器开始布局，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标。</p>
<p>第五步，Render 树和节点显示坐标都有了，就调用每个节点 paint 方法，把它们绘制出来。</p>
<h5 id="5-display的block、inline和inline-block的区别"><a href="#5-display的block、inline和inline-block的区别" class="headerlink" title="5. display的block、inline和inline-block的区别"></a>5. display的block、inline和inline-block的区别</h5><p>（1）<strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>（2）<strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>（3）<strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
<h5 id="6-隐藏元素的方法有哪些"><a href="#6-隐藏元素的方法有哪些" class="headerlink" title="6.隐藏元素的方法有哪些"></a>6.隐藏元素的方法有哪些</h5><p><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</p>
<p><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</p>
<p><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</p>
<p><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</p>
<p><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</p>
<p><strong>clip&#x2F;clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p>
<p>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p>
<h5 id="7-link和-import的区别"><a href="#7-link和-import的区别" class="headerlink" title="7.link和@import的区别"></a>7.link和@import的区别</h5><p>两者都是外部引用CSS的方式，它们的区别如下：</p>
<ul>
<li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<h5 id="8-CSS3中有哪些新特性"><a href="#8-CSS3中有哪些新特性" class="headerlink" title="8.CSS3中有哪些新特性"></a>8.CSS3中有哪些新特性</h5><ul>
<li><p>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</p>
</li>
<li><p>圆角 （border-radius:8px）</p>
</li>
<li><p>多列布局 （multi-column layout）</p>
</li>
<li><p>阴影和反射 （Shadoweflect）</p>
</li>
<li><p>文字特效 （text-shadow）</p>
</li>
<li><p>文字渲染 （Text-decoration）</p>
</li>
<li><p>线性渐变 （gradient）</p>
</li>
<li><p>旋转 （transform）</p>
</li>
<li><p>增加了旋转,缩放,定位,倾斜,动画,多背景</p>
</li>
</ul>
<h5 id="9-Sass、Less-是什么？为什么要使用他们？"><a href="#9-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="9.Sass、Less 是什么？为什么要使用他们？"></a>9.Sass、Less 是什么？为什么要使用他们？</h5><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法&#x2F;语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p>
<p><strong>为什么要使用它们？</strong></p>
<ul>
<li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li>
<li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ul>
<h5 id="10-单行、多行文本溢出隐藏"><a href="#10-单行、多行文本溢出隐藏" class="headerlink" title="10. 单行、多行文本溢出隐藏"></a>10. 单行、多行文本溢出隐藏</h5><ul>
<li><p>单行文本溢出</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行文本溢出</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p>
</li>
</ul>
<h5 id="11-为什么需要清除浮动？清除浮动的方式"><a href="#11-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="11.为什么需要清除浮动？清除浮动的方式?"></a>11.为什么需要清除浮动？清除浮动的方式?</h5><p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素会跟随其后</li>
<li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li>
</ul>
<p><strong>清除浮动的方式如下：</strong></p>
<ul>
<li>给父级div定义<code>height</code>属性</li>
<li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li>
<li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li>
<li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li>
</ul>
<h5 id="12-display、float、position的关系"><a href="#12-display、float、position的关系" class="headerlink" title="12.display、float、position的关系"></a>12.display、float、position的关系</h5><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p>
<p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p>
<p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p>
<p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h5 id="13-css3新增的选择符有哪些？"><a href="#13-css3新增的选择符有哪些？" class="headerlink" title="13.css3新增的选择符有哪些？"></a>13.css3新增的选择符有哪些？</h5><p>css3新增的选择器主要分为属性选择器，关系选择器，结构化伪类选择器，伪元素选择器四类，具体介绍如下：</p>
<p><strong>1.属性选择器</strong></p>
<p>属性选择器，可以根据网页标记的属性及属性值来标记。</p>
<p>属性选择器主要包括<code>E[att^=value]</code>、<code>E[att$=value]</code>和<code>E[att*=value]</code>这三种性选择器。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 属性选择符</span><br><span class="line"><span class="selector-attr">[attribute]</span>: 选择所有带有该属性的元素</span><br><span class="line">[attribute=value]: 选择所有带有该属性且值等于给定值的元素</span><br><span class="line">[attribute~=value]: 选择所有带有该属性且值包含给定词汇的元素</span><br><span class="line">[attribute|=value]: 选择所有带有该属性且值以指定字符串开头的元素</span><br><span class="line">[attribute^=value]: 选择所有带有该属性且值以指定字符串开始的元素</span><br><span class="line">[attribute$=value]: 选择所有带有该属性且值以指定字符串结束的元素</span><br><span class="line">[attribute*=value]: 选择所有带有该属性且值包含指定字符串的元素</span><br></pre></td></tr></table></figure>

<p><strong>2.关系选择器</strong></p>
<p>CSS3中的关系选择器主要包括子代选择器和兄弟选择器。</p>
<p>(1)关系选择器</p>
<p>(2)临近兄弟选择器</p>
<p>(3)普通兄弟选择器</p>
<p><strong>3.结构化伪类选择器</strong></p>
<p>结构化伪类选择器可以减少文档内class属性和id属性的定义，使文档变得更加简洁。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">3.1</span> 伪类选择符</span><br><span class="line"><span class="selector-pseudo">:active</span>: 选择当前正在被激活的元素</span><br><span class="line">:checked: 选择所有被选中的元素</span><br><span class="line">:disabled: 选择所有被禁用的元素</span><br><span class="line">:enabled: 选择所有未被禁用的元素</span><br><span class="line">:first-child: 选择某个元素下的第一个子元素</span><br><span class="line">:hover: 选择所有当前鼠标悬停的元素</span><br><span class="line">:<span class="built_in">nth-child</span>(n): 选择某个元素下的第n个子元素</span><br><span class="line">:last-child: 选择某个元素下的最后一个子元素</span><br><span class="line">:<span class="built_in">not</span>(selector): 选择非指定元素的所有元素</span><br><span class="line">:target: 选择当前活动的目标元素</span><br><span class="line"><span class="number">3.2</span>组合选择符</span><br><span class="line">element, element: 选择所有指定元素</span><br><span class="line">element parent: 选择指定元素的父元素</span><br><span class="line">element&gt;child: 选择指定元素的直接子元素</span><br><span class="line">element+element: 选择紧接在指定元素后的元素</span><br><span class="line">element~element: 选择指定元素后的所有同级元素</span><br></pre></td></tr></table></figure>

<p><strong>4.伪元素选择器</strong></p>
<p>伪元素选择器一般使一个标记后紧跟英文冒号”:”，英文冒号后是伪元素名。</p>
<p>伪元素选择器可以帮助我们利用CSS创建新标签元素,而不需要HTML标签,从而简化HTML结构。</p>
<p>：：before      在元素前面插入内容<br>        ：：after         在元素后面插入内容<br>注意</p>
<pre><code>        before和after创建一个元素 ,但是属于行内元素
        新创建的这个元素在文档树中是找不到的,所以我们称为伪元素
        语法: element:before 
        before和after必须有content属性
        before在父元素内容的前面创建元素, after 在父元素内容的后面插入元素
        伪元素选择器和标签选择器一 样,权重为1
</code></pre>
<h4 id="八-ES6"><a href="#八-ES6" class="headerlink" title="八.ES6"></a>八.ES6</h4><h5 id="1-如果new一个箭头函数会怎么样？"><a href="#1-如果new一个箭头函数会怎么样？" class="headerlink" title="1.如果new一个箭头函数会怎么样？"></a>1.如果new一个箭头函数会怎么样？</h5><p>箭头函数是由ES6提出来的，他并没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>
<p>new操作符的实现步骤如下：</p>
<ul>
<li><p>创建一个对象</p>
</li>
<li><p>将构造函数的作用域给新对象</p>
</li>
<li><p>指向构造对象中的代码，构造函数中的this指向该对象</p>
</li>
<li><p>返回新的对象</p>
<p>所以，上面的第二，三步，箭头函数都是没有办法执行的</p>
</li>
</ul>
<h5 id="2-箭头函数和普通函数的区别"><a href="#2-箭头函数和普通函数的区别" class="headerlink" title="2.箭头函数和普通函数的区别"></a>2.箭头函数和普通函数的区别</h5><ul>
<li>箭头函数比普通函数更加简洁<ul>
<li>如果没有参数，就直接写一个空括号即可</li>
<li>如果只有一个参数，可以省去参数的括号</li>
<li>如果有多个参数，用逗号分割</li>
<li>如果函数体的返回值只有一句，可以省略大括号</li>
<li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li>
</ul>
</li>
<li>箭头函数没有自己的this</li>
<li>箭头函数继承来的指向永远不会发生改变</li>
<li>call(),apply(),bind（）等方法不能改变箭头函数的this指向</li>
<li>箭头函数不能作为构造函数使用</li>
<li>箭头函数没有自己的arguments</li>
<li>箭头函数没有prototypes</li>
<li>箭头函数不能做Generator函数，不能使用yeild关键字</li>
</ul>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
</search>
