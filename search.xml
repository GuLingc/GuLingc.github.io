<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>node基础概念</title>
    <url>/2023/07/29/node%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><a name="IHs7V"></a></p>
<h4 id="1-跨域产生的原因以及解决方案"><a href="#1-跨域产生的原因以及解决方案" class="headerlink" title="1.跨域产生的原因以及解决方案"></a>1.跨域产生的原因以及解决方案</h4><ol>
<li>什么是<code>跨域</code>？<ol>
<li>广义：指一个域下的文档或脚本试图去请求另一个域下的资源</li>
<li>狭义：浏览器不能执行其他网站的脚本，是由浏览器的<a href="https://baike.baidu.com/item/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/3927875">同源策略</a>限制的一类请求场景，从一个域名的网页去请求另一个域名的资源时，域名，端口，协议任一不同，都是跨域。</li>
</ol>
</li>
<li>为什么会产生跨域？</li>
</ol>
<p><code>跨域是因为浏览器的同源策略的限制</code>，是浏览器的一种安全机制，服务端之间是不存在跨域的。所谓的同源指的是两个页面具有相同放入<code>协议，主机和端口，三者任一不相同</code>就会产生跨域。<br />跨域举例：<img src="/img/study/%E8%B7%A8%E5%9F%9F.png" alt="image.png"><br>3. 跨域的解决方案</p>
<pre><code>  1. jsonp跨域
</code></pre>
<p><code>jsonp</code>(JSON with Padding),是json的一种“使用模式”，可以让页面跨域读取数据，其本质是利用script标签的开放策略，浏览器传递callback参数到后端，后端返回数据时会将callback参数作为函数名来包裹数据，从而浏览器久可以跨域请求数据并制定函数来自动处理返回数据。</p>
<pre><code>  2. 跨域资源共享（cors）
</code></pre>
<p>跨域资源共享是一个W3C标准，允许浏览器向跨域服务器发送请求，从而客服ajax只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前，所有主流浏览器是同XMLHttpRequest对象都可支持该功能，IE8和IE8需要使用XDomainRequest对象进行兼容。<br />CORS整个通信过程都是浏览器自动完成，浏览器一旦发现ajax请求跨源，就会自动在头信息中增加Origin字段，用来说明本次请求来自哪个源（协议+域名+端口）。因此，实现CORS通信的关键是服务器，需要服务器配置Access-Control-Allow-Origin头信息。当CORS请求需要携带cookie时，需要服务端配置Access-Control-Allow-Credentials头信息，前端也需要设置withCredentials。</p>
<pre><code>  3. 服务器代理
</code></pre>
<p>服务器代理，顾名思义即在发送跨域请求时，后端进行代理中转请求至服务器端，然后将获取的数据返回给前端。<br />一般适用于以下场景：</p>
<ul>
<li>针对IE7及以下浏览器摒弃Flash插件的情况，配置代理接口与前端页面同源，并中转目标服务器接口，则ajax请求不存在跨域问题。</li>
<li>外网前端页面无法访问内网接口，配置代理接口允许前端页面访问，并中转内网接口，则外网前端页面可以跨域访问内网接口。</li>
</ul>
<h4 id="2-body-parser这个中间件是做什么用的？"><a href="#2-body-parser这个中间件是做什么用的？" class="headerlink" title="2.body-parser这个中间件是做什么用的？"></a>2.body-parser这个中间件是做什么用的？</h4><p><code>body-parser</code>是一个<code>Node.js中间件</code>，用于解析HTTP请求中的请求体（RequestBody）,并将其转化为JSON格式或其它格式的数据对象。它可以帮助开发者方便的从POST,PUT,DELETE等请求中获取请求体数据，并进行相应的处理。具体来说，body-parser支持以下几种请求体数据格式：</p>
<pre><code>  1. JSON格式：通过json()方式解析JSON格式的请求体数据，并将其转换为JS对象
  2. URL编码格式：通过urlencoded()方法解析URL编码格式的请求体数据，并将其转换为JS对象
  3. 多部分数据格式：通过multipart()方法解析多部份数据格式的请求体数据，并将其转换为JS对象。
</code></pre>
<p>例子：简单实用body-parser解析请求体数据的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 URL 编码格式的请求体数据</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 JSON 格式的请求体数据</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">json</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 POST 请求</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`username: <span class="subst">$&#123;username&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Login Success!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running on http://localhost:3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面使用body-parser中间件分别解析了URL编码格式和JSON格式的请求体数据，并通过<code>req.body获取请求体数据对象</code>。在POST请求处理的函数中，打印了用户输入的用户名和密码，并返回了一个登录成功对的响应消息。<br />在使用body-parser中间件时需要根据实际情况选择合适的解析方法，并注意配置参数，以<code>防止出现安全漏洞和错误数据</code>。同时，在处理HTTP请求时，需要对请求体数据进行有效性验证和安全性检查，以保证数据的可靠性和完整性。<br><a name="cmj9f"></a></p>
<h4 id="3-什么是Koa"><a href="#3-什么是Koa" class="headerlink" title="3.什么是Koa?"></a>3.什么是Koa?</h4><p>nodejs中除了express框架，另一个非常流行的Node Web服务器框架就是Koa。<br />Koa是一个精简的node框架，最大的特点是独特的中间件流程控制，典型的洋葱模型。<br><a name="vCEni"></a></p>
<h4 id="4-对Koa洋葱模型的理解"><a href="#4-对Koa洋葱模型的理解" class="headerlink" title="4.对Koa洋葱模型的理解"></a>4.对Koa洋葱模型的理解</h4><p><code>Koa框架</code>是一个Node.js的<code>Web应用程序框架</code>，它通过中间件机制实现了业务逻辑的分层和复用。Koa中使用的中间件机制被称为<code>洋葱模型</code>，其核心思想是将HTTP请求和响应对象一次传递给各个中间件函数，形成一条类似于洋葱的管道，最终返回响应结果。<br />具体来说，Koa 洋葱模型的处理流程可以大致分为四个阶段：</p>
<ol>
<li><code>请求阶段</code>：从外到内依次执行请求相关的中间件，例如解析请求体、设置响应头等操作。</li>
<li><code>业务阶段</code>：执行业务逻辑相关的中间件，例如处理授权、验证身份、路由分发等操作。</li>
<li><code>响应阶段</code>：从内到外依次执行响应相关的中间件，例如格式化响应数据、设置响应头等操作。</li>
<li><code>错误处理阶段</code>：如果在前面的中间件过程中出现了错误，则会跳过后续中间件并交给错误处理中间件来处理异常情况。</li>
</ol>
<p>在这个过程中，每个中间件都可以根据需要对请求和响应对象进行修改、扩展、封装等操作，并将控制权传递给下一个中间件，形成了一条流水线式的处理模式。这种设计可以大大提高代码的复用和可读性，同时也方便了对程序行为进行监控、调试和优化。<br />总之，Koa 洋葱模型是一种基于中间件机制的 Web 应用程序开发方法，它通过将请求和响应对象依次传递给各个中间件函数，实现了<code>业务逻辑的分层和复用</code>，并且具有灵活、可扩展和高效的特点。</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>React项目搭建</title>
    <url>/2023/07/15/React%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><a name="RMA4X"></a></p>
<h4 id="1-工具：搭建React项目的脚手架"><a href="#1-工具：搭建React项目的脚手架" class="headerlink" title="1.工具：搭建React项目的脚手架"></a>1.工具：搭建React项目的脚手架</h4><ul>
<li>create-react-app 项目名称</li>
</ul>
<p>如果采用<strong>create-react-app 项目名称</strong>的方式搭建脚手架则生成的项目中<strong>不含TS配置</strong>需要自己手动搭建TS配置。存在的弊端如下：</p>
<ul>
<li>弊端一：项目基于webpack，webpack所有配置是隐藏的</li>
<li>弊端二：TS React项目配置难度较大。并且将ts代码转化成js代码的编译方式有TS Compiler和Lable两种方式，两者最好都要配置，难度较大。</li>
<li>**create-react-app 项目名称 –template typescript	**—&gt;利用git bash窗口创建，如果利用黑窗口前面加npm或npx</li>
</ul>
<p>上面脚手架配置的好处：</p>
<ul>
<li>create-react-app：创建了一个react项目</li>
<li>后面内容的存在同时配置TS的支持<br><a name="ZEINP"></a></li>
</ul>
<h4 id="2-项目配置"><a href="#2-项目配置" class="headerlink" title="2.项目配置"></a>2.项目配置</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 配置项目的icon</li>
<li><input checked="" disabled="" type="checkbox"> 配置项目的标题</li>
<li><input checked="" disabled="" type="checkbox"> 配置项目别名等（craco.config.ts）—&gt;配置src的别名放置出现多个..&#x2F;..&#x2F;的嵌套</li>
</ul>
<p>因为别名的配置是基于webpack配置的，它的东西又被隐藏了，所以需要借助craco:create-react-app config。因为react5.0版本太新，所以在安装craco的时候也需要安装最新版本 <strong>npm install @craco&#x2F;craco@alpha -D</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 配置tsconfig.json</li>
</ul>
<hr>
<ol>
<li>配置项目别名步骤<ol>
<li>安装craco</li>
</ol>
</li>
</ol>
<p>如果react采用的是4.0版本采用 npm install @craco&#x2F;craco -D<br />如果react采用的是5.0版本使用 npm install @craco&#x2F;craco@alpha -D</p>
<pre><code>  2. 创建craco.config.js文件
</code></pre>
<p>在根目录下即src外层创建该文件；</p>
<pre><code>  3. 配置文件内容
</code></pre>
<p>__dirname:当前目录；<br />craco.config.js文件内容代码配置如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/36149953/1688779766826-45a8cbe1-cce1-4934-bc87-4c7f43b7d959.png#averageHue=%231f1f1e&clientId=u1852a6ab-090d-4&from=paste&height=239&id=VfUjZ&originHeight=358&originWidth=1262&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=40751&status=done&style=none&taskId=u46fe2aaf-0645-43b2-a9a9-fac4e5958f5&title=&width=841.3333333333334" alt="image.png"><br />然后在tsconfig.json文件里配置路径的相关内容，否则在其他文件中无法使用<img src="https://cdn.nlark.com/yuque/0/2023/png/36149953/1688780000886-adf4a7e7-46dd-41ab-874d-cd0e9d9eb97e.png#averageHue=%231f1e1e&clientId=u1852a6ab-090d-4&from=paste&height=211&id=OJNOL&originHeight=439&originWidth=1642&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=81403&status=done&style=none&taskId=u0dac8866-f677-4ad2-95e4-57c7f4dcbc2&title=&width=791" alt="image.png"><br />并且将package.json中前三个的react-script改成craco,进行合并使用，否则在编译生成页面的时候仍会报错<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/36149953/1688780248235-74205790-13db-4768-b459-a36783256b38.png#averageHue=%23201f1f&clientId=u1852a6ab-090d-4&from=paste&height=331&id=rEXck&originHeight=496&originWidth=1376&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=59791&status=done&style=none&taskId=u692a69e1-85cd-4bc8-82cd-b1bc1364a86&title=&width=917.3333333333334" alt="image.png"></p>
<hr>
<p><a name="bf73J"></a></p>
<h4 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3.代码规范"></a>3.代码规范</h4><p><a name="KTJUH"></a></p>
<h5 id="集成editorgonfid配置"><a href="#集成editorgonfid配置" class="headerlink" title="集成editorgonfid配置"></a>集成editorgonfid配置</h5><p>editorConfig配置有助于为不同的IDE编译器上处理同一个项目的多个开发人员维护一致的编码风格。<br />新建.editorconfig文件，无后缀</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># http://editorconfig.org</span></span><br><span class="line"></span><br><span class="line"><span class="string">root</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[<span class="string">*</span>] <span class="comment"># 表示所有文件适用</span></span><br><span class="line"><span class="string">charset</span> <span class="string">=</span> <span class="string">utf-8</span> <span class="comment"># 设置文件字符集为 utf-8</span></span><br><span class="line"><span class="string">indent_style</span> <span class="string">=</span> <span class="string">space</span> <span class="comment"># 缩进风格（tab | space）</span></span><br><span class="line"><span class="string">indent_size</span> <span class="string">=</span> <span class="number">2</span> <span class="comment"># 缩进大小</span></span><br><span class="line"><span class="string">end_of_line</span> <span class="string">=</span> <span class="string">lf</span> <span class="comment"># 控制换行类型(lf | cr | crlf)</span></span><br><span class="line"><span class="string">trim_trailing_whitespace</span> <span class="string">=</span> <span class="literal">true</span> <span class="comment"># 去除行尾的任意空白字符</span></span><br><span class="line"><span class="string">insert_final_newline</span> <span class="string">=</span> <span class="literal">true</span> <span class="comment"># 始终在文件末尾插入一个新行</span></span><br><span class="line"></span><br><span class="line">[<span class="string">*.md</span>] <span class="comment"># 表示仅 md 文件适用以下规则</span></span><br><span class="line"><span class="string">max_line_length</span> <span class="string">=</span> <span class="string">off</span></span><br><span class="line"><span class="string">trim_trailing_whitespace</span> <span class="string">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><a name="RYthi"></a></p>
<h5 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h5><p>prettier保持代码的某一种风格，格式化代码，使其更加美观</p>
<pre><code>  1. 安装prettier:  npm install prettier -D
  2. 在项目的根目录下创建.prettierrc文件
  3. 测试prettier是否生效
     - 在代码中保存代码；
     - 配置一次性修改的命令
</code></pre>
<p>在package.json中配置一个script</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;prettier&quot;</span><span class="punctuation">:</span><span class="string">&quot;prettier --writer .&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以输入命令手动格式化所有未被忽略的文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">npm run prettier</span><br></pre></td></tr></table></figure>

<p>   1.4**.忽略不被格式化的文件**</p>
<ul>
<li>在根目录下创建.prettierignore文件</li>
<li>在文件中写入要忽略的文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /build/*</span></span><br><span class="line"><span class="comment"># .local</span></span><br><span class="line"><span class="comment"># .output.js</span></span><br><span class="line"><span class="comment"># /node_modules/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># **/*.svg</span></span><br><span class="line"><span class="comment"># **/*.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /public/*</span></span><br></pre></td></tr></table></figure>

<p><a name="Dneg3"></a></p>
<h5 id="使用EsLint检测"><a href="#使用EsLint检测" class="headerlink" title="使用EsLint检测"></a>使用EsLint检测</h5><pre><code>  1. 安装eslint:  npm install selint -D
  2. 由于eslint的配置比较多所以采用命令的方式自动生成配置文件
</code></pre>
<ul>
<li>对eslint进行初始化：npx eslint –init</li>
<li>输入y生成配置文件</li>
<li>在三个选项中选择第二个，检测错误并发现问题，第三个选项多个一个强制代码转换，由于上面配置过prettier所以不需要</li>
<li>选择第一个js模块化</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/36149953/1688787438696-77368468-8679-48e6-acd1-fcc007851d99.png#averageHue=%232a2624&clientId=u1852a6ab-090d-4&from=paste&height=86&id=uce8802d4&originHeight=129&originWidth=560&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18463&status=done&style=none&taskId=ue3d7ef62-1bc2-4b1a-9ff3-8632ea9a94a&title=&width=373.3333333333333" alt="image.png"></p>
<ul>
<li>因为这个项目是React项目所以选择React</li>
<li>因为使用了TS所以是yes</li>
<li>选择浏览器Browser;选择js文件；选择yes;选择npm</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/36149953/1688787835482-e4f2da1c-14fb-4c6f-8320-fa870ae72fea.png#averageHue=%2321201f&clientId=u1852a6ab-090d-4&from=paste&height=372&id=u919de287&originHeight=558&originWidth=1253&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=89605&status=done&style=none&taskId=u699203ee-314f-40b6-bc7a-3426cc05c11&title=&width=835.3333333333334" alt="image.png"><br />1.3 修改生成的配置文件<br />     由于上方生成的配置文件只选择在浏览器环境下运行，而项目中又参杂了node所以为了保证可以在node环境下进行，需要在配置文件的“env”里加入:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;node&quot;</span>:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>为了使require正常使用要在配置文件的rules中加入如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;@typescript-eslint/no-var-requires&#x27;</span>: <span class="string">&#x27;off&#x27;</span></span><br></pre></td></tr></table></figure>

<p>1.4  vsCode需要安装eslint插件<br />1.5解决eslint和prettier冲突的问题：<br />安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装。<br />npm install eslint-plugin-prettier eslint-config-prettier -D<br />安装成功之后在.eslintrc.js中增加下方代码：使eslint与prettier代码风格一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;plugin:prettier/recommended&#x27;</span></span><br></pre></td></tr></table></figure>

<p>prettier和eslint存在冲突，暂时不要用尤其是eslint;<br><a name="mZATs"></a></p>
<h4 id="4-项目目录结构的划分"><a href="#4-项目目录结构的划分" class="headerlink" title="4.项目目录结构的划分"></a>4.项目目录结构的划分</h4><ul>
<li>assets放置静态资源：例如：css,img</li>
<li>base-ui多个项目使用的共同组件</li>
<li>components:存放当前项目中多出使用到的共同组件</li>
<li>hook:自定义hook———–&gt;一般不单独建文件夹</li>
<li>router</li>
<li>store</li>
<li>service:网络请求</li>
<li>utils:存放工具，例如：全局自定义弹窗</li>
<li>views:存放视图，展示不同页面的组件<br><a name="Bya3Z"></a></li>
</ul>
<h4 id="5-对CSS样式的重置"><a href="#5-对CSS样式的重置" class="headerlink" title="5.对CSS样式的重置"></a>5.对CSS样式的重置</h4><ul>
<li>normalize.css:  npm install normalize.css</li>
</ul>
<p>在tsx文件中引入normalize.css,从而对默认的css进行重置</p>
<ul>
<li>reset.less：自己在静态文件夹下的css文件中建立文档，定义 jk重置的css样式</li>
</ul>
<p>如果使用less需要安装指定版本：<br />npm install <a href="mailto:&#99;&#114;&#x61;&#x63;&#x6f;&#x2d;&#x6c;&#x65;&#115;&#x73;&#64;&#x32;&#x2e;&#x31;&#x2e;&#48;&#45;&#97;&#108;&#112;&#104;&#97;&#x2e;&#x30;">&#99;&#114;&#x61;&#x63;&#x6f;&#x2d;&#x6c;&#x65;&#115;&#x73;&#64;&#x32;&#x2e;&#x31;&#x2e;&#48;&#45;&#97;&#108;&#112;&#104;&#97;&#x2e;&#x30;</a><br><a name="Q38Z8"></a></p>
<h4 id="6-路由的配置"><a href="#6-路由的配置" class="headerlink" title="6.路由的配置"></a>6.路由的配置</h4><pre><code>  1. 路由的搭建：npm install react-router-dom
  2. 在写路由的时候与vue使用compoent不同的是React用的element，并且element后面跟的是组件实例（&lt;Discover /&gt;）而非Discover。由于组件实例属于jsx语法，所以写路有的文件不能是.ts应该是.tsx。凡是tsx文件都需要引入React(import React from &#39;react&#39;)。
  3. 如果使用路由，最外层的index.tsx中的APP必须被router包裹
</code></pre>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;normalize.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./assets/css/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;@/App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<pre><code>1.4：写路由组件的一般做法：
</code></pre>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123;memo&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">ReactNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">//如果想要读取组件中包括的子组件需要定义children,因为props本身中没有children，不能直接读取传入的子组件</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>; <span class="comment">//传入children写，不传则去掉</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  height?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式一：直接对props进行类型约束：props:IProps</span></span><br><span class="line"><span class="comment">// const Download = (props: IProps) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;div&gt;name:&#123;props.name&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;div&gt;age:&#123;props.age&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;div&gt;height:&#123;props.height&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   );</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：借助ts泛型</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Download</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>name:&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>age:&#123;props.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>height:&#123;props.height&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最好使用memo函数，它的导出性能比较好</span></span><br><span class="line"><span class="comment">// export default Download;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Download</span>)</span><br></pre></td></tr></table></figure>

<p>1.5react与vue二级路由的不同之处：</p>
<ul>
<li>vue的二级路由的path不用加一级路由的路径</li>
<li>react的二级路由的path需要加一级路由的路径否则会报错（如：&#x2F;discover&#x2F;recommend）<br><a name="XmGJ7"></a></li>
</ul>
<h4 id="7-配置react基本代码的一键生成模板"><a href="#7-配置react基本代码的一键生成模板" class="headerlink" title="7.配置react基本代码的一键生成模板"></a>7.配置react基本代码的一键生成模板</h4><p>已知tsx文件基础的模板代码格式如下：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="variable constant_">FC</span>, <span class="title class_">ReactNode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPprops</span> &#123;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Djradio</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">IPprops</span>&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Djradio<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Djradio</span>);</span><br></pre></td></tr></table></figure>

<p>利用工具自动生成代码时将可变的文件名称（如：Djradio）改成${1:Home},生成的代码如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;react typescript&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsreact&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;import React, &#123; memo &#125; from \&quot;react\&quot;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;import type &#123; FC, ReactNode &#125; from \&quot;react\&quot;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;interface IPprops &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;  children?: ReactNode;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;const $&#123;1:Home&#125;: FC&lt;IPprops&gt; = () =&gt; &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;  return &lt;div&gt;$&#123;1:Home&#125;&lt;/div&gt;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&#125;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;export default memo($&#123;1:Home&#125;);&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react typescript&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>点击Vscode-&gt;文件-&gt;首选项-&gt;配置用户片段代码-&gt;输入Typescriptreact-&gt;将得到的代码粘贴<br />因为上方代码的prefix的值时tsreact所以在一个新的tsx文件中输入tsreact回车会自动生成react的基础代码。<br><a name="ei0TE"></a></p>
<h4 id="8-状态管理"><a href="#8-状态管理" class="headerlink" title="8.状态管理"></a>8.状态管理</h4><p>状态管理选择：</p>
<ul>
<li>redux:目前React中使用最多的状态管理库；</li>
<li>@reduxjs&#x2F;toolkit:redux工具，更方便的使用redux</li>
</ul>
<p><strong>操作：</strong><br />不需要单独安装redux,只需要如下步骤：<br />npm insatll @reduxjs&#x2F;toolkit react-dom<br />接着在store文件夹中创建index.ts文件,编写store内容：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>在最外层的index.tsx文件中导入store和Provider，Proviindex.tsxder标签位于最外层，使其他页面可以利用store。</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;normalize.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./assets/css/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;@/App&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果想要保存数据可以在store中创建一个文件夹modules,然后在其下面新建一个ts文件（如counter.ts文件）。<strong>在这个文件中及时initalState（初始化）和reducers中无内容也要书写，因为他们和name是必写内容，否则会报错。</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  <span class="attr">initialState</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;Hello Redux&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span></span><br></pre></td></tr></table></figure>

<p>然后导出的内容需要放在store里面否则无效。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&quot;./modules/counter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">counter</span>: counterReducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p><a name="k85va"></a></p>
<h4 id="9-网络请求封装axios"><a href="#9-网络请求封装axios" class="headerlink" title="9.网络请求封装axios"></a>9.网络请求封装axios</h4><pre><code>  1. 安装axios
</code></pre>
<p>npm install axios<br />由于最新班的axios版本过高会有报错，所以安装1.1版本<br />npm install <a href="mailto:&#x61;&#x78;&#x69;&#x6f;&#115;&#x40;&#x31;&#x2e;&#49;&#46;&#x30;">&#x61;&#x78;&#x69;&#x6f;&#115;&#x40;&#x31;&#x2e;&#49;&#46;&#x30;</a></p>
<pre><code>  2. 1
     &lt;a name=&quot;sFgV1&quot;&gt;&lt;/a&gt;
</code></pre>
<h4 id="10-如何打包项目："><a href="#10-如何打包项目：" class="headerlink" title="10.如何打包项目："></a>10.如何打包项目：</h4><pre><code>  1. npm run build
  2. 打包完成之后在本地跑起来：npm install -g serve
  3. 启动服务器以build作为资源：serve -s build
     &lt;a name=&quot;blAiO&quot;&gt;&lt;/a&gt;
</code></pre>
<h4 id="11-css-in-js库"><a href="#11-css-in-js库" class="headerlink" title="11.css-in-js库"></a>11.css-in-js库</h4><p>react是用js写html的框架，为了在react框架中使用js编写一切代码，使用css-in-js库编写css代码，<strong>style-components是近期使用人数最多的css-in-js库</strong>，它的优点如下：</p>
<ul>
<li>可以编写实际的CSS代码来设计组件样式，也不需要组件和样式之间的映射，即创建后就是一个正常的React 组件，直接在JSX中引入即可</li>
<li>在一个组件内会将结构、样式和逻辑写在一起，虽然这违背了关注点分离的原则，但是这有利于组件间的隔离。为了顺应组件化的潮流</li>
<li>使用styled-components不需要再使用className属性来控制样式，而是将样式写成更具语义化的组件的形式</li>
<li>使用style-components会随机生成一个class名称，这样不会污染到全局变量，当然因为随机生成，维护会增加难度</li>
</ul>
<p><strong>使用步骤：</strong></p>
<ul>
<li>安装style-components:npm install styled-components -D</li>
<li>在引入和使用styled-components之前需要先对其进行类型声明否则会报错。</li>
</ul>
<p>类型声明的几种形式：</p>
<ul>
<li>typescript内置DOM</li>
<li>第三方：<ul>
<li>库内部已经有类型声明（eg：axios）</li>
<li>react&#x2F;react-dom&#x3D;&gt;@types&#x2F;react @types&#x2F;react-dom</li>
<li>自己写的类型声明</li>
</ul>
</li>
<li>解决方式： npm i –save-dev @types&#x2F;styled-components<br><a name="uGWID"></a></li>
</ul>
<h4 id="12-react的第三方库-antd"><a href="#12-react的第三方库-antd" class="headerlink" title="12.react的第三方库-antd"></a>12.react的第三方库-antd</h4><ul>
<li>安装antd:npm install antd –save</li>
<li>如果想要使用图标需要单独再安装一个图标库：npm install –save @ant-design&#x2F;icons<br><a name="W8YPl"></a></li>
</ul>
<h4 id="13-动态添加classname"><a href="#13-动态添加classname" class="headerlink" title="13.动态添加classname"></a><a href="https://blog.csdn.net/sheep_yyx/article/details/125661895">13.动态添加classname</a></h4><p>安装classname库，当利用map之类动态数据遍历的时候可以动态添加classname<br />npm install classname</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试</title>
    <url>/2023/07/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="一-闭包与原型："><a href="#一-闭包与原型：" class="headerlink" title="一.闭包与原型："></a>一.闭包与原型：</h4><h5 id="1-什么是闭包？闭包的用途？"><a href="#1-什么是闭包？闭包的用途？" class="headerlink" title="1.什么是闭包？闭包的用途？"></a>1.什么是闭包？闭包的用途？</h5><p>1）闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<p>2）js中闭包的优点和缺点：</p>
<p>优点：</p>
<pre><code>       1.保护函数内的变量安全
        
       2.在内存中维持一个变量(用的太多就变成了缺点，占内存) ；
        
       1. 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。

       2. 方便调用上下文的局部变量。

       3. 加强封装性，可以达到对变量的保护作用。
</code></pre>
<p>缺点:</p>
<pre><code>      1.常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
    
      2.还有有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。
</code></pre>
<p>闭包的特性:</p>
<pre><code>    1. 函数嵌套函数

    2. 内部函数可以访问外部函数的变量

    3. 参数和变量不会被回收。

    4. 闭包的典型框架应该就是jquery了。
</code></pre>
<h4 id="二-js基础"><a href="#二-js基础" class="headerlink" title="二.js基础"></a>二.js基础</h4><h5 id="1-JS执行上下文"><a href="#1-JS执行上下文" class="headerlink" title="1.JS执行上下文"></a>1.JS执行上下文</h5><ul>
<li>全局执行上下文：这是默认或基本执行上下文。不在任何函数内的代码都属于全局上下问，一个程序中只能由一个全局执行上下文。他要做的有两件事：<ul>
<li>创建一个全局对象，在浏览器中为(<code>window</code>)。</li>
<li>将 <code>this</code> 的值设置为全局对象。</li>
</ul>
</li>
<li>函数执行上下文:每次调用函数时，都会为该函数创建一个全新的执行上下文。每个函数都有自己的执行上下文，但它是在调用函数时创建的，这个上下文可以保护里面的私有变量和外界互不干扰。</li>
<li>Eval执行上下文：在 <code>eval</code> 函数执行代码也会产生一种特殊的执行上下文，但由于我们通常不会使用它，因此就不讨论了。</li>
<li>每当一个函数执行完毕，则这个函数的执行上下文也将从栈中弹出，等到所有函数都运行完毕，要关闭页面的时候，全局上下文也将出栈释放，程序运行结束。如果当前上下文中的某些内容，被当前上下文以外的东西占用，那么当前上下文是不能被释放的，这就是我们熟知的闭包(Closure)。</li>
</ul>
<h5 id="2-const定义的对象属性可以被修改吗？"><a href="#2-const定义的对象属性可以被修改吗？" class="headerlink" title="2.const定义的对象属性可以被修改吗？"></a>2.const定义的对象属性可以被修改吗？</h5><p>答：const定义的对象属性可以被修改，但是const定义即基本能数据类型string,number等，定义之后不能背修改，修改之后会报错。</p>
<p>原因：</p>
<p>const定义中的不变指的时对象的指针不变，因为修改对象那个中的属性并不会让指向对象的指针发生变化，所以指向对象属性可以被修改。</p>
<h5 id="3-数据类型检测的方式有哪些？"><a href="#3-数据类型检测的方式有哪些？" class="headerlink" title="3.数据类型检测的方式有哪些？"></a>3.数据类型检测的方式有哪些？</h5><ul>
<li><p>typeof:其中数组、对象、null都会被判断为object，其他判断都正确。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);              <span class="comment">// object    </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>
</li>
</ul>
<h4 id="4-js为什么要进行变量提升？会导致什么问题？"><a href="#4-js为什么要进行变量提升？会导致什么问题？" class="headerlink" title="4.js为什么要进行变量提升？会导致什么问题？"></a>4.js为什么要进行变量提升？会导致什么问题？</h4><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问而且不会报错。</p>
<p><strong>为什么执行变量提升？</strong></p>
<ul>
<li><p>提高性能：解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间。</p>
</li>
<li><p>容错性更好：声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</p>
<p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p>
</li>
</ul>
<h4 id="三-js提高"><a href="#三-js提高" class="headerlink" title="三.js提高"></a>三.js提高</h4><h5 id="1-简述事件循环："><a href="#1-简述事件循环：" class="headerlink" title="1.简述事件循环："></a>1.简述事件循环：</h5><p>先同步再异步，先微任务再宏任务。</p>
<p>js是一个单线程的。函数执行的过程是将函数执行上下文压入栈中，直到栈中清空，表示这个任务执行结束。为了保证异步的函数按顺序执行，出现了task queue（任务队列）。任务队列的作用是将各种事件或异步的操作进行通知时加入其回调函数。js引擎会不停的从任务队列中取出任务，压入到栈中执行，执行完成后再取下一个任务执行，如此一直到任务队列为空。如果为空，会一直等待新的任务出现。这种不停的等待处理事件的循环称之为事件循环。</p>
<h5 id="2-虚拟dom是什么-原理-优缺点"><a href="#2-虚拟dom是什么-原理-优缺点" class="headerlink" title="2.虚拟dom是什么? 原理? 优缺点?"></a>2.虚拟dom是什么? 原理? 优缺点?</h5><p>虚拟dom：虚拟dom的本质上是js对象或者是对真实DOM的抽象，状态变更时，记录新书和旧树的差异，最后把差异更新在真正的dom中。（定义及原理）</p>
<p>优点：</p>
<ul>
<li>保证性能下限：虚拟DOM可以通过diff算法找出最小差异，然后批量的进行patch，这种操作虽然比不上手动优化，但是比起出包的DOM操作性能要好很多，因此虚拟DOM可以保证性能的下限。</li>
<li>无需手动操作DOM：虚拟DOM的diff和patch都是在一次更新中自动进行的，我们无需手动操作DOM，极大的提高了开发效率。</li>
<li>跨平台：虚拟dom的本质是js对象，而DOM与平台强相关，相比之下虚拟dom可以进行更方便地跨平台操作，例如服务器的渲染，移动端开发等等。</li>
</ul>
<p>缺点：</p>
<p>无法进行极致优化:在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化，比如VScode采用直接手动操作DOM的方式进行极端的性能优</p>
<h4 id="四-vue2"><a href="#四-vue2" class="headerlink" title="四.vue2"></a>四.vue2</h4><h5 id="1-vue双向绑定的原理是什么？"><a href="#1-vue双向绑定的原理是什么？" class="headerlink" title="1.vue双向绑定的原理是什么？"></a>1.vue双向绑定的原理是什么？</h5><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。</p>
<h5 id="2-Computed和Watch的区别"><a href="#2-Computed和Watch的区别" class="headerlink" title="2.Computed和Watch的区别"></a>2.Computed和Watch的区别</h5><p><strong>对于Computed:</strong></p>
<ul>
<li><p>它支持缓存，只有依赖的数据发生了变化，才会重新计算</p>
</li>
<li><p>不支持异步，当Computed中由异步操作时无法监听数据的变化</p>
</li>
<li><p>computed的值默认走缓存，计算属性是基于他们的响应式依赖进行缓存的，</p>
</li>
<li><p>也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</p>
<p>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</p>
<p>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</p>
<p><strong>对于Watch：</strong></p>
<ul>
<li>它不支持缓存，数据变化时，它就会触发相应的操作</li>
<li>支持异步监听</li>
<li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li>
<li>当一个属性发生变化时，就需要执行相应的操作</li>
<li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul>
<li>immediate：组件加载立即触发回调函数</li>
<li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>
</ul>
</li>
</ul>
<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>
<p><strong>总结：</strong></p>
<ul>
<li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li>
<li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>
</ul>
<p><strong>运用场景：</strong></p>
<ul>
<li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li>
<li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
</li>
</ul>
<h5 id="3-vue中的keep-alive的作用是什么？怎么使用？"><a href="#3-vue中的keep-alive的作用是什么？怎么使用？" class="headerlink" title="3.vue中的keep-alive的作用是什么？怎么使用？"></a>3.vue中的keep-alive的作用是什么？怎么使用？</h5><p><strong>概念</strong></p>
<p>keep-alive是Vue的内置组件，当它包括动态组件时，会缓存不活动的组件实例，该组件不会被销毁。</p>
<p><strong>作用</strong></p>
<p>用来缓存组件，避免多次加载相同的组件，减少性能的消耗，提高用户体验</p>
<p><strong>属性</strong></p>
<ul>
<li>include：字符串或正则表达式。只有匹配的组件会被缓存</li>
<li>exclude：字符串或正则表达式。任何匹配的组件都不会被缓存</li>
</ul>
<p><strong>使用场景</strong></p>
<p>比如：有一个列表页面和一个详情页面，那么用户可能会经常执行打开详情 &#x3D;&gt; 返回列表 &#x3D;&gt; 打开详情，那么就可以对列表组件使用进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染页面，从而节省内存开销。</p>
<p><strong>使用方式</strong></p>
<ul>
<li>在App.vue中使用keep-alive组件缓存页面</li>
<li>按条件缓存使用include，excode判断是否存在缓存<ul>
<li>将缓存name作为keep的组件，如果多个可以用逗号分开</li>
<li>将不换存的name为nokeep的组件</li>
<li>还可以使用属性绑定动态判断</li>
</ul>
</li>
<li>在router目录的index.js中<ul>
<li>使用meta:{keepAlive&#x3D;true},表示需要缓存</li>
</ul>
</li>
<li>在App.vue中进行判断</li>
</ul>
<h4 id="五-html"><a href="#五-html" class="headerlink" title="五.html"></a>五.html</h4><h5 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h5><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>
<ul>
<li><strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li>
<li><strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它指向的⽂件时，就会进行下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li>
</ul>
<h5 id="2-HTML5有哪些更新？"><a href="#2-HTML5有哪些更新？" class="headerlink" title="2.HTML5有哪些更新？"></a>2.HTML5有哪些更新？</h5><ul>
<li>语义化标签：如：header–&gt;定义文档的头部，nav,footer,article,section,aside</li>
<li>媒体标签：audio–&gt;音频，video视频，source</li>
<li>数据存储：localStorage、sessionStorage</li>
<li>表单</li>
<li>进度条，度量器</li>
<li>DOM查询操作</li>
<li>Web存储</li>
<li>input标签新增属性：placeholder、autocomplete、autofocus、required </li>
<li>其他：拖放，canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</li>
</ul>
<p><strong>移除的元素有：</strong></p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<h5 id="3-对HTML语义化的理解"><a href="#3-对HTML语义化的理解" class="headerlink" title="3.对HTML语义化的理解"></a>3.对HTML语义化的理解</h5><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p>
<p>语义化的优点如下：</p>
<ul>
<li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<h4 id="六-Ts（TypeScript）"><a href="#六-Ts（TypeScript）" class="headerlink" title="六.Ts（TypeScript）"></a>六.Ts（TypeScript）</h4><p>TS是微软开发的一个开源的编程语言，通过在js的基础上添加静态类型定义构建而成。</p>
<h5 id="1-TS常用类型："><a href="#1-TS常用类型：" class="headerlink" title="1.TS常用类型："></a>1.TS常用类型：</h5><ul>
<li>JS中已有类型<ul>
<li>原始类型：number,string,boolean,null,undefined,symbol</li>
<li>对象类型：object（数组，函数，对象等）</li>
</ul>
</li>
<li>TS新增类型<ul>
<li>联合类型，自定义类型，接口，元组，字面量类型，枚举，void，any等</li>
</ul>
</li>
</ul>
<h5 id="2-ts中type和Interface的异同："><a href="#2-ts中type和Interface的异同：" class="headerlink" title="2.ts中type和Interface的异同："></a>2.ts中type和Interface的异同：</h5><p>type：是类型别名，给一些类型的组合起别名，方便使用，例如<code>type ID = string | number;</code></p>
<p>Interface:是接口。有点像type，可以用来代表一种类型组合，但它的范围更小一些，只能描述对象的结构。</p>
<p>它们写法有一点区别，type 后面需要用 &#x3D; ，interface 后面不需要 &#x3D; ，直接就带上 { 。</p>
<p>&#x3D;&#x3D;type 和 interface 的不同点有：&#x3D;&#x3D;</p>
<ul>
<li><p>type 后面有  &#x3D; ，interface 没有。</p>
</li>
<li><p>type 可以描述任何类型组合，interface 只能描述对象结构。</p>
</li>
<li><p>interface 可以继承自（extends）interface 或对象结构的 type。type 也可以通过  &amp; 做对象结构的继承。</p>
</li>
<li><p>多次声明的同名 ，interface 会进行声明合并，type 则不允许多次声明。</p>
</li>
</ul>
<h4 id="七-css"><a href="#七-css" class="headerlink" title="七.css"></a>七.css</h4><h5 id="1-浮动"><a href="#1-浮动" class="headerlink" title="1.浮动"></a>1.浮动</h5><p><strong>1.为什么使用浮动。</strong><br>很多网页布局效果，标准流是做不到，所以就要是用浮动来完成布局，浮动可以改变排列方式。</p>
<p><strong>2.浮动引起的问题。</strong><br> 父元素高度塌陷，高度无法撑开。<br>与元素同级的非浮动元素会紧随其后(遮盖现象)。<br>如果一个元素浮动，则该元素之前的元素也需要浮动;否则会影响页面显示的结构</p>
<p><strong>3.解决方案(清除浮动）。</strong><br>给父元素固定高度。没有设置浮动时，父元素的高度是height：auto 高度是由子元素撑开的；这个方法的缺点是，因为设置了固定高度，它的维护性是很差的，适用于固定高度布局。<br>在浮动元素增加一个空div元素，设置样式 clear：both  要放在空元素上。缺点：布局添加了毫无意义的标签，如果有大量的使用无意义的div标签那么就造成很大的冗余。<br>为父元素设置 overflow:hidden 。缺点：受限于overflow:hidden的主要功能，如果子元素的尺寸大于父元素，或者子元素中的内容过多，那么多出来的这一部分将不会溢出，也不会显示出来，会直接被hidden起来；因此这个方法不适用于子元素的内容过多；<br>使用伪类 :after 只需要在父元素上添加一个class;类使用after伪元素，在父元素现有内容的末尾添加新的内容。添加的内容是一个display: block; clear: both;的空元素；</p>
<h5 id="4-什么是重绘和重排？它们的区别是什么？"><a href="#4-什么是重绘和重排？它们的区别是什么？" class="headerlink" title="4.什么是重绘和重排？它们的区别是什么？"></a>4.什么是重绘和重排？它们的区别是什么？</h5><p><strong>重绘</strong>：当页面元素样式的改变不影响布局时，浏览器重新对元素进行更新的过程叫做重绘。</p>
<p><strong>重排</strong>：当页面元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程叫做重排也叫做回流。重绘不一定需要重排，重排必然会导致重绘</p>
<p>1、重排：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</p>
<p>1）添加、删除可见的dom</p>
<p>2）元素的位置改变</p>
<p>3）元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）</p>
<p>4）页面渲染初始化</p>
<p>5）浏览器窗口尺寸改变</p>
<p>2、重绘：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<h5 id="4-dom树是怎么生成的？"><a href="#4-dom树是怎么生成的？" class="headerlink" title="4.dom树是怎么生成的？"></a>4.dom树是怎么生成的？</h5><p>页面得渲染流程总得俩说就五步，创建 DOM 树——创建 StyleRules——创建 Render 树——布局Layout（重排）——绘制 Painting（重绘）</p>
<p>第一步，用 HTML 分析器，分析 HTML 元素，构建一颗 DOM 树(标记化和树构建)。</p>
<p>第二步，用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。</p>
<p>第三步，将 DOM 树和样式表，关联起来，构建一颗 Render 树(这一过程又称为 Attachment)。每个 DOM 节点都有attach 方法，接受样式信息，返回一个render对象(又名renderer)。这些 render 对象最终会被构建成一颗 Render 树。</p>
<p>第四步，有了 Render 树，浏览器开始布局，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标。</p>
<p>第五步，Render 树和节点显示坐标都有了，就调用每个节点 paint 方法，把它们绘制出来。</p>
<h5 id="5-display的block、inline和inline-block的区别"><a href="#5-display的block、inline和inline-block的区别" class="headerlink" title="5. display的block、inline和inline-block的区别"></a>5. display的block、inline和inline-block的区别</h5><p>（1）<strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>（2）<strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>（3）<strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
<h5 id="6-隐藏元素的方法有哪些"><a href="#6-隐藏元素的方法有哪些" class="headerlink" title="6.隐藏元素的方法有哪些"></a>6.隐藏元素的方法有哪些</h5><p><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</p>
<p><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</p>
<p><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</p>
<p><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</p>
<p><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</p>
<p><strong>clip&#x2F;clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p>
<p>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p>
<h5 id="7-link和-import的区别"><a href="#7-link和-import的区别" class="headerlink" title="7.link和@import的区别"></a>7.link和@import的区别</h5><p>两者都是外部引用CSS的方式，它们的区别如下：</p>
<ul>
<li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<h5 id="8-CSS3中有哪些新特性"><a href="#8-CSS3中有哪些新特性" class="headerlink" title="8.CSS3中有哪些新特性"></a>8.CSS3中有哪些新特性</h5><ul>
<li><p>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</p>
</li>
<li><p>圆角 （border-radius:8px）</p>
</li>
<li><p>多列布局 （multi-column layout）</p>
</li>
<li><p>阴影和反射 （Shadoweflect）</p>
</li>
<li><p>文字特效 （text-shadow）</p>
</li>
<li><p>文字渲染 （Text-decoration）</p>
</li>
<li><p>线性渐变 （gradient）</p>
</li>
<li><p>旋转 （transform）</p>
</li>
<li><p>增加了旋转,缩放,定位,倾斜,动画,多背景</p>
</li>
</ul>
<h5 id="9-Sass、Less-是什么？为什么要使用他们？"><a href="#9-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="9.Sass、Less 是什么？为什么要使用他们？"></a>9.Sass、Less 是什么？为什么要使用他们？</h5><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法&#x2F;语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p>
<p><strong>为什么要使用它们？</strong></p>
<ul>
<li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li>
<li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ul>
<h5 id="10-单行、多行文本溢出隐藏"><a href="#10-单行、多行文本溢出隐藏" class="headerlink" title="10. 单行、多行文本溢出隐藏"></a>10. 单行、多行文本溢出隐藏</h5><ul>
<li><p>单行文本溢出</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行文本溢出</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p>
</li>
</ul>
<h5 id="11-为什么需要清除浮动？清除浮动的方式"><a href="#11-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="11.为什么需要清除浮动？清除浮动的方式?"></a>11.为什么需要清除浮动？清除浮动的方式?</h5><p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素会跟随其后</li>
<li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li>
</ul>
<p><strong>清除浮动的方式如下：</strong></p>
<ul>
<li>给父级div定义<code>height</code>属性</li>
<li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li>
<li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li>
<li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li>
</ul>
<h5 id="12-display、float、position的关系"><a href="#12-display、float、position的关系" class="headerlink" title="12.display、float、position的关系"></a>12.display、float、position的关系</h5><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p>
<p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p>
<p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p>
<p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h5 id="13-css3新增的选择符有哪些？"><a href="#13-css3新增的选择符有哪些？" class="headerlink" title="13.css3新增的选择符有哪些？"></a>13.css3新增的选择符有哪些？</h5><p>css3新增的选择器主要分为属性选择器，关系选择器，结构化伪类选择器，伪元素选择器四类，具体介绍如下：</p>
<p><strong>1.属性选择器</strong></p>
<p>属性选择器，可以根据网页标记的属性及属性值来标记。</p>
<p>属性选择器主要包括<code>E[att^=value]</code>、<code>E[att$=value]</code>和<code>E[att*=value]</code>这三种性选择器。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 属性选择符</span><br><span class="line"><span class="selector-attr">[attribute]</span>: 选择所有带有该属性的元素</span><br><span class="line">[attribute=value]: 选择所有带有该属性且值等于给定值的元素</span><br><span class="line">[attribute~=value]: 选择所有带有该属性且值包含给定词汇的元素</span><br><span class="line">[attribute|=value]: 选择所有带有该属性且值以指定字符串开头的元素</span><br><span class="line">[attribute^=value]: 选择所有带有该属性且值以指定字符串开始的元素</span><br><span class="line">[attribute$=value]: 选择所有带有该属性且值以指定字符串结束的元素</span><br><span class="line">[attribute*=value]: 选择所有带有该属性且值包含指定字符串的元素</span><br></pre></td></tr></table></figure>

<p><strong>2.关系选择器</strong></p>
<p>CSS3中的关系选择器主要包括子代选择器和兄弟选择器。</p>
<p>(1)关系选择器</p>
<p>(2)临近兄弟选择器</p>
<p>(3)普通兄弟选择器</p>
<p><strong>3.结构化伪类选择器</strong></p>
<p>结构化伪类选择器可以减少文档内class属性和id属性的定义，使文档变得更加简洁。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">3.1</span> 伪类选择符</span><br><span class="line"><span class="selector-pseudo">:active</span>: 选择当前正在被激活的元素</span><br><span class="line">:checked: 选择所有被选中的元素</span><br><span class="line">:disabled: 选择所有被禁用的元素</span><br><span class="line">:enabled: 选择所有未被禁用的元素</span><br><span class="line">:first-child: 选择某个元素下的第一个子元素</span><br><span class="line">:hover: 选择所有当前鼠标悬停的元素</span><br><span class="line">:<span class="built_in">nth-child</span>(n): 选择某个元素下的第n个子元素</span><br><span class="line">:last-child: 选择某个元素下的最后一个子元素</span><br><span class="line">:<span class="built_in">not</span>(selector): 选择非指定元素的所有元素</span><br><span class="line">:target: 选择当前活动的目标元素</span><br><span class="line"><span class="number">3.2</span>组合选择符</span><br><span class="line">element, element: 选择所有指定元素</span><br><span class="line">element parent: 选择指定元素的父元素</span><br><span class="line">element&gt;child: 选择指定元素的直接子元素</span><br><span class="line">element+element: 选择紧接在指定元素后的元素</span><br><span class="line">element~element: 选择指定元素后的所有同级元素</span><br></pre></td></tr></table></figure>

<p><strong>4.伪元素选择器</strong></p>
<p>伪元素选择器一般使一个标记后紧跟英文冒号”:”，英文冒号后是伪元素名。</p>
<p>伪元素选择器可以帮助我们利用CSS创建新标签元素,而不需要HTML标签,从而简化HTML结构。</p>
<p>：：before      在元素前面插入内容<br>        ：：after         在元素后面插入内容<br>注意</p>
<pre><code>        before和after创建一个元素 ,但是属于行内元素
        新创建的这个元素在文档树中是找不到的,所以我们称为伪元素
        语法: element:before 
        before和after必须有content属性
        before在父元素内容的前面创建元素, after 在父元素内容的后面插入元素
        伪元素选择器和标签选择器一 样,权重为1
</code></pre>
<h4 id="八-ES6"><a href="#八-ES6" class="headerlink" title="八.ES6"></a>八.ES6</h4><h5 id="1-如果new一个箭头函数会怎么样？"><a href="#1-如果new一个箭头函数会怎么样？" class="headerlink" title="1.如果new一个箭头函数会怎么样？"></a>1.如果new一个箭头函数会怎么样？</h5><p>箭头函数是由ES6提出来的，他并没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>
<p>new操作符的实现步骤如下：</p>
<ul>
<li><p>创建一个对象</p>
</li>
<li><p>将构造函数的作用域给新对象</p>
</li>
<li><p>指向构造对象中的代码，构造函数中的this指向该对象</p>
</li>
<li><p>返回新的对象</p>
<p>所以，上面的第二，三步，箭头函数都是没有办法执行的</p>
</li>
</ul>
<h5 id="2-箭头函数和普通函数的区别"><a href="#2-箭头函数和普通函数的区别" class="headerlink" title="2.箭头函数和普通函数的区别"></a>2.箭头函数和普通函数的区别</h5><ul>
<li>箭头函数比普通函数更加简洁<ul>
<li>如果没有参数，就直接写一个空括号即可</li>
<li>如果只有一个参数，可以省去参数的括号</li>
<li>如果有多个参数，用逗号分割</li>
<li>如果函数体的返回值只有一句，可以省略大括号</li>
<li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li>
</ul>
</li>
<li>箭头函数没有自己的this</li>
<li>箭头函数继承来的指向永远不会发生改变</li>
<li>call(),apply(),bind（）等方法不能改变箭头函数的this指向</li>
<li>箭头函数不能作为构造函数使用</li>
<li>箭头函数没有自己的arguments</li>
<li>箭头函数没有prototypes</li>
<li>箭头函数不能做Generator函数，不能使用yeild关键字</li>
</ul>
]]></content>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
</search>
