<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面试 | 林南而瑜的星球</title><meta name="author" content="林南而瑜"><meta name="copyright" content="林南而瑜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一.闭包与原型：1.什么是闭包？闭包的用途？1）闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。 2）js中闭包的优点和缺点： 优点：        1.保护函数内的变量安全                 2.在内存中维持一个变量(用的太多就变成了缺点，占内存) ；                 1. 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试">
<meta property="og:url" content="http://example.com/2023/07/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="林南而瑜的星球">
<meta property="og:description" content="一.闭包与原型：1.什么是闭包？闭包的用途？1）闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。 2）js中闭包的优点和缺点： 优点：        1.保护函数内的变量安全                 2.在内存中维持一个变量(用的太多就变成了缺点，占内存) ；                 1. 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=638285213,1746517464&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800">
<meta property="article:published_time" content="2023-07-15T01:42:24.000Z">
<meta property="article:modified_time" content="2023-07-20T13:32:16.656Z">
<meta property="article:author" content="林南而瑜">
<meta property="article:tag" content="复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=638285213,1746517464&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 林南而瑜","link":"链接: ","source":"来源: 林南而瑜的星球","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-20 21:32:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=638285213,1746517464&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800')"><nav id="nav"><span id="blog-info"><a href="/" title="林南而瑜的星球"><span class="site-name">林南而瑜的星球</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-15T01:42:24.000Z" title="发表于 2023-07-15 09:42:24">2023-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-20T13:32:16.656Z" title="更新于 2023-07-20 21:32:16">2023-07-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="一-闭包与原型："><a href="#一-闭包与原型：" class="headerlink" title="一.闭包与原型："></a>一.闭包与原型：</h4><h5 id="1-什么是闭包？闭包的用途？"><a href="#1-什么是闭包？闭包的用途？" class="headerlink" title="1.什么是闭包？闭包的用途？"></a>1.什么是闭包？闭包的用途？</h5><p>1）闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<p>2）js中闭包的优点和缺点：</p>
<p>优点：</p>
<pre><code>       1.保护函数内的变量安全
        
       2.在内存中维持一个变量(用的太多就变成了缺点，占内存) ；
        
       1. 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。

       2. 方便调用上下文的局部变量。

       3. 加强封装性，可以达到对变量的保护作用。
</code></pre>
<p>缺点:</p>
<pre><code>      1.常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
    
      2.还有有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。
</code></pre>
<p>闭包的特性:</p>
<pre><code>    1. 函数嵌套函数

    2. 内部函数可以访问外部函数的变量

    3. 参数和变量不会被回收。

    4. 闭包的典型框架应该就是jquery了。
</code></pre>
<h4 id="二-js基础"><a href="#二-js基础" class="headerlink" title="二.js基础"></a>二.js基础</h4><h5 id="1-JS执行上下文"><a href="#1-JS执行上下文" class="headerlink" title="1.JS执行上下文"></a>1.JS执行上下文</h5><ul>
<li>全局执行上下文：这是默认或基本执行上下文。不在任何函数内的代码都属于全局上下问，一个程序中只能由一个全局执行上下文。他要做的有两件事：<ul>
<li>创建一个全局对象，在浏览器中为(<code>window</code>)。</li>
<li>将 <code>this</code> 的值设置为全局对象。</li>
</ul>
</li>
<li>函数执行上下文:每次调用函数时，都会为该函数创建一个全新的执行上下文。每个函数都有自己的执行上下文，但它是在调用函数时创建的，这个上下文可以保护里面的私有变量和外界互不干扰。</li>
<li>Eval执行上下文：在 <code>eval</code> 函数执行代码也会产生一种特殊的执行上下文，但由于我们通常不会使用它，因此就不讨论了。</li>
<li>每当一个函数执行完毕，则这个函数的执行上下文也将从栈中弹出，等到所有函数都运行完毕，要关闭页面的时候，全局上下文也将出栈释放，程序运行结束。如果当前上下文中的某些内容，被当前上下文以外的东西占用，那么当前上下文是不能被释放的，这就是我们熟知的闭包(Closure)。</li>
</ul>
<h5 id="2-const定义的对象属性可以被修改吗？"><a href="#2-const定义的对象属性可以被修改吗？" class="headerlink" title="2.const定义的对象属性可以被修改吗？"></a>2.const定义的对象属性可以被修改吗？</h5><p>答：const定义的对象属性可以被修改，但是const定义即基本能数据类型string,number等，定义之后不能背修改，修改之后会报错。</p>
<p>原因：</p>
<p>const定义中的不变指的时对象的指针不变，因为修改对象那个中的属性并不会让指向对象的指针发生变化，所以指向对象属性可以被修改。</p>
<h5 id="3-数据类型检测的方式有哪些？"><a href="#3-数据类型检测的方式有哪些？" class="headerlink" title="3.数据类型检测的方式有哪些？"></a>3.数据类型检测的方式有哪些？</h5><ul>
<li><p>typeof:其中数组、对象、null都会被判断为object，其他判断都正确。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []);              <span class="comment">// object    </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span>===<span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>
</li>
</ul>
<h4 id="4-js为什么要进行变量提升？会导致什么问题？"><a href="#4-js为什么要进行变量提升？会导致什么问题？" class="headerlink" title="4.js为什么要进行变量提升？会导致什么问题？"></a>4.js为什么要进行变量提升？会导致什么问题？</h4><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问而且不会报错。</p>
<p><strong>为什么执行变量提升？</strong></p>
<ul>
<li><p>提高性能：解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间。</p>
</li>
<li><p>容错性更好：声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</p>
<p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p>
</li>
</ul>
<h4 id="三-js提高"><a href="#三-js提高" class="headerlink" title="三.js提高"></a>三.js提高</h4><h5 id="1-简述事件循环："><a href="#1-简述事件循环：" class="headerlink" title="1.简述事件循环："></a>1.简述事件循环：</h5><p>先同步再异步，先微任务再宏任务。</p>
<p>js是一个单线程的。函数执行的过程是将函数执行上下文压入栈中，直到栈中清空，表示这个任务执行结束。为了保证异步的函数按顺序执行，出现了task queue（任务队列）。任务队列的作用是将各种事件或异步的操作进行通知时加入其回调函数。js引擎会不停的从任务队列中取出任务，压入到栈中执行，执行完成后再取下一个任务执行，如此一直到任务队列为空。如果为空，会一直等待新的任务出现。这种不停的等待处理事件的循环称之为事件循环。</p>
<h5 id="2-虚拟dom是什么-原理-优缺点"><a href="#2-虚拟dom是什么-原理-优缺点" class="headerlink" title="2.虚拟dom是什么? 原理? 优缺点?"></a>2.虚拟dom是什么? 原理? 优缺点?</h5><p>虚拟dom：虚拟dom的本质上是js对象或者是对真实DOM的抽象，状态变更时，记录新书和旧树的差异，最后把差异更新在真正的dom中。（定义及原理）</p>
<p>优点：</p>
<ul>
<li>保证性能下限：虚拟DOM可以通过diff算法找出最小差异，然后批量的进行patch，这种操作虽然比不上手动优化，但是比起出包的DOM操作性能要好很多，因此虚拟DOM可以保证性能的下限。</li>
<li>无需手动操作DOM：虚拟DOM的diff和patch都是在一次更新中自动进行的，我们无需手动操作DOM，极大的提高了开发效率。</li>
<li>跨平台：虚拟dom的本质是js对象，而DOM与平台强相关，相比之下虚拟dom可以进行更方便地跨平台操作，例如服务器的渲染，移动端开发等等。</li>
</ul>
<p>缺点：</p>
<p>无法进行极致优化:在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化，比如VScode采用直接手动操作DOM的方式进行极端的性能优</p>
<h4 id="四-vue2"><a href="#四-vue2" class="headerlink" title="四.vue2"></a>四.vue2</h4><h5 id="1-vue双向绑定的原理是什么？"><a href="#1-vue双向绑定的原理是什么？" class="headerlink" title="1.vue双向绑定的原理是什么？"></a>1.vue双向绑定的原理是什么？</h5><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。</p>
<h5 id="2-Computed和Watch的区别"><a href="#2-Computed和Watch的区别" class="headerlink" title="2.Computed和Watch的区别"></a>2.Computed和Watch的区别</h5><p><strong>对于Computed:</strong></p>
<ul>
<li><p>它支持缓存，只有依赖的数据发生了变化，才会重新计算</p>
</li>
<li><p>不支持异步，当Computed中由异步操作时无法监听数据的变化</p>
</li>
<li><p>computed的值默认走缓存，计算属性是基于他们的响应式依赖进行缓存的，</p>
</li>
<li><p>也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</p>
<p>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</p>
<p>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</p>
<p><strong>对于Watch：</strong></p>
<ul>
<li>它不支持缓存，数据变化时，它就会触发相应的操作</li>
<li>支持异步监听</li>
<li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li>
<li>当一个属性发生变化时，就需要执行相应的操作</li>
<li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul>
<li>immediate：组件加载立即触发回调函数</li>
<li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>
</ul>
</li>
</ul>
<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>
<p><strong>总结：</strong></p>
<ul>
<li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li>
<li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>
</ul>
<p><strong>运用场景：</strong></p>
<ul>
<li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li>
<li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
</li>
</ul>
<h5 id="3-vue中的keep-alive的作用是什么？怎么使用？"><a href="#3-vue中的keep-alive的作用是什么？怎么使用？" class="headerlink" title="3.vue中的keep-alive的作用是什么？怎么使用？"></a>3.vue中的keep-alive的作用是什么？怎么使用？</h5><p><strong>概念</strong></p>
<p>keep-alive是Vue的内置组件，当它包括动态组件时，会缓存不活动的组件实例，该组件不会被销毁。</p>
<p><strong>作用</strong></p>
<p>用来缓存组件，避免多次加载相同的组件，减少性能的消耗，提高用户体验</p>
<p><strong>属性</strong></p>
<ul>
<li>include：字符串或正则表达式。只有匹配的组件会被缓存</li>
<li>exclude：字符串或正则表达式。任何匹配的组件都不会被缓存</li>
</ul>
<p><strong>使用场景</strong></p>
<p>比如：有一个列表页面和一个详情页面，那么用户可能会经常执行打开详情 &#x3D;&gt; 返回列表 &#x3D;&gt; 打开详情，那么就可以对列表组件使用进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染页面，从而节省内存开销。</p>
<p><strong>使用方式</strong></p>
<ul>
<li>在App.vue中使用keep-alive组件缓存页面</li>
<li>按条件缓存使用include，excode判断是否存在缓存<ul>
<li>将缓存name作为keep的组件，如果多个可以用逗号分开</li>
<li>将不换存的name为nokeep的组件</li>
<li>还可以使用属性绑定动态判断</li>
</ul>
</li>
<li>在router目录的index.js中<ul>
<li>使用meta:{keepAlive&#x3D;true},表示需要缓存</li>
</ul>
</li>
<li>在App.vue中进行判断</li>
</ul>
<h4 id="五-html"><a href="#五-html" class="headerlink" title="五.html"></a>五.html</h4><h5 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h5><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>
<ul>
<li><strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li>
<li><strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它指向的⽂件时，就会进行下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li>
</ul>
<h5 id="2-HTML5有哪些更新？"><a href="#2-HTML5有哪些更新？" class="headerlink" title="2.HTML5有哪些更新？"></a>2.HTML5有哪些更新？</h5><ul>
<li>语义化标签：如：header–&gt;定义文档的头部，nav,footer,article,section,aside</li>
<li>媒体标签：audio–&gt;音频，video视频，source</li>
<li>数据存储：localStorage、sessionStorage</li>
<li>表单</li>
<li>进度条，度量器</li>
<li>DOM查询操作</li>
<li>Web存储</li>
<li>input标签新增属性：placeholder、autocomplete、autofocus、required </li>
<li>其他：拖放，canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</li>
</ul>
<p><strong>移除的元素有：</strong></p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<h5 id="3-对HTML语义化的理解"><a href="#3-对HTML语义化的理解" class="headerlink" title="3.对HTML语义化的理解"></a>3.对HTML语义化的理解</h5><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p>
<p>语义化的优点如下：</p>
<ul>
<li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<h4 id="六-Ts（TypeScript）"><a href="#六-Ts（TypeScript）" class="headerlink" title="六.Ts（TypeScript）"></a>六.Ts（TypeScript）</h4><p>TS是微软开发的一个开源的编程语言，通过在js的基础上添加静态类型定义构建而成。</p>
<h5 id="1-TS常用类型："><a href="#1-TS常用类型：" class="headerlink" title="1.TS常用类型："></a>1.TS常用类型：</h5><ul>
<li>JS中已有类型<ul>
<li>原始类型：number,string,boolean,null,undefined,symbol</li>
<li>对象类型：object（数组，函数，对象等）</li>
</ul>
</li>
<li>TS新增类型<ul>
<li>联合类型，自定义类型，接口，元组，字面量类型，枚举，void，any等</li>
</ul>
</li>
</ul>
<h5 id="2-ts中type和Interface的异同："><a href="#2-ts中type和Interface的异同：" class="headerlink" title="2.ts中type和Interface的异同："></a>2.ts中type和Interface的异同：</h5><p>type：是类型别名，给一些类型的组合起别名，方便使用，例如<code>type ID = string | number;</code></p>
<p>Interface:是接口。有点像type，可以用来代表一种类型组合，但它的范围更小一些，只能描述对象的结构。</p>
<p>它们写法有一点区别，type 后面需要用 &#x3D; ，interface 后面不需要 &#x3D; ，直接就带上 { 。</p>
<p>&#x3D;&#x3D;type 和 interface 的不同点有：&#x3D;&#x3D;</p>
<ul>
<li><p>type 后面有  &#x3D; ，interface 没有。</p>
</li>
<li><p>type 可以描述任何类型组合，interface 只能描述对象结构。</p>
</li>
<li><p>interface 可以继承自（extends）interface 或对象结构的 type。type 也可以通过  &amp; 做对象结构的继承。</p>
</li>
<li><p>多次声明的同名 ，interface 会进行声明合并，type 则不允许多次声明。</p>
</li>
</ul>
<h4 id="七-css"><a href="#七-css" class="headerlink" title="七.css"></a>七.css</h4><h5 id="1-浮动"><a href="#1-浮动" class="headerlink" title="1.浮动"></a>1.浮动</h5><p><strong>1.为什么使用浮动。</strong><br>很多网页布局效果，标准流是做不到，所以就要是用浮动来完成布局，浮动可以改变排列方式。</p>
<p><strong>2.浮动引起的问题。</strong><br> 父元素高度塌陷，高度无法撑开。<br>与元素同级的非浮动元素会紧随其后(遮盖现象)。<br>如果一个元素浮动，则该元素之前的元素也需要浮动;否则会影响页面显示的结构</p>
<p><strong>3.解决方案(清除浮动）。</strong><br>给父元素固定高度。没有设置浮动时，父元素的高度是height：auto 高度是由子元素撑开的；这个方法的缺点是，因为设置了固定高度，它的维护性是很差的，适用于固定高度布局。<br>在浮动元素增加一个空div元素，设置样式 clear：both  要放在空元素上。缺点：布局添加了毫无意义的标签，如果有大量的使用无意义的div标签那么就造成很大的冗余。<br>为父元素设置 overflow:hidden 。缺点：受限于overflow:hidden的主要功能，如果子元素的尺寸大于父元素，或者子元素中的内容过多，那么多出来的这一部分将不会溢出，也不会显示出来，会直接被hidden起来；因此这个方法不适用于子元素的内容过多；<br>使用伪类 :after 只需要在父元素上添加一个class;类使用after伪元素，在父元素现有内容的末尾添加新的内容。添加的内容是一个display: block; clear: both;的空元素；</p>
<h5 id="4-什么是重绘和重排？它们的区别是什么？"><a href="#4-什么是重绘和重排？它们的区别是什么？" class="headerlink" title="4.什么是重绘和重排？它们的区别是什么？"></a>4.什么是重绘和重排？它们的区别是什么？</h5><p><strong>重绘</strong>：当页面元素样式的改变不影响布局时，浏览器重新对元素进行更新的过程叫做重绘。</p>
<p><strong>重排</strong>：当页面元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程叫做重排也叫做回流。重绘不一定需要重排，重排必然会导致重绘</p>
<p>1、重排：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</p>
<p>1）添加、删除可见的dom</p>
<p>2）元素的位置改变</p>
<p>3）元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）</p>
<p>4）页面渲染初始化</p>
<p>5）浏览器窗口尺寸改变</p>
<p>2、重绘：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<h5 id="4-dom树是怎么生成的？"><a href="#4-dom树是怎么生成的？" class="headerlink" title="4.dom树是怎么生成的？"></a>4.dom树是怎么生成的？</h5><p>页面得渲染流程总得俩说就五步，创建 DOM 树——创建 StyleRules——创建 Render 树——布局Layout（重排）——绘制 Painting（重绘）</p>
<p>第一步，用 HTML 分析器，分析 HTML 元素，构建一颗 DOM 树(标记化和树构建)。</p>
<p>第二步，用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。</p>
<p>第三步，将 DOM 树和样式表，关联起来，构建一颗 Render 树(这一过程又称为 Attachment)。每个 DOM 节点都有attach 方法，接受样式信息，返回一个render对象(又名renderer)。这些 render 对象最终会被构建成一颗 Render 树。</p>
<p>第四步，有了 Render 树，浏览器开始布局，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标。</p>
<p>第五步，Render 树和节点显示坐标都有了，就调用每个节点 paint 方法，把它们绘制出来。</p>
<h5 id="5-display的block、inline和inline-block的区别"><a href="#5-display的block、inline和inline-block的区别" class="headerlink" title="5. display的block、inline和inline-block的区别"></a>5. display的block、inline和inline-block的区别</h5><p>（1）<strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>（2）<strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>（3）<strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
<h5 id="6-隐藏元素的方法有哪些"><a href="#6-隐藏元素的方法有哪些" class="headerlink" title="6.隐藏元素的方法有哪些"></a>6.隐藏元素的方法有哪些</h5><p><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</p>
<p><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</p>
<p><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</p>
<p><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</p>
<p><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</p>
<p><strong>clip&#x2F;clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p>
<p>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p>
<h5 id="7-link和-import的区别"><a href="#7-link和-import的区别" class="headerlink" title="7.link和@import的区别"></a>7.link和@import的区别</h5><p>两者都是外部引用CSS的方式，它们的区别如下：</p>
<ul>
<li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<h5 id="8-CSS3中有哪些新特性"><a href="#8-CSS3中有哪些新特性" class="headerlink" title="8.CSS3中有哪些新特性"></a>8.CSS3中有哪些新特性</h5><ul>
<li><p>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</p>
</li>
<li><p>圆角 （border-radius:8px）</p>
</li>
<li><p>多列布局 （multi-column layout）</p>
</li>
<li><p>阴影和反射 （Shadoweflect）</p>
</li>
<li><p>文字特效 （text-shadow）</p>
</li>
<li><p>文字渲染 （Text-decoration）</p>
</li>
<li><p>线性渐变 （gradient）</p>
</li>
<li><p>旋转 （transform）</p>
</li>
<li><p>增加了旋转,缩放,定位,倾斜,动画,多背景</p>
</li>
</ul>
<h5 id="9-Sass、Less-是什么？为什么要使用他们？"><a href="#9-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="9.Sass、Less 是什么？为什么要使用他们？"></a>9.Sass、Less 是什么？为什么要使用他们？</h5><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法&#x2F;语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p>
<p><strong>为什么要使用它们？</strong></p>
<ul>
<li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li>
<li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ul>
<h5 id="10-单行、多行文本溢出隐藏"><a href="#10-单行、多行文本溢出隐藏" class="headerlink" title="10. 单行、多行文本溢出隐藏"></a>10. 单行、多行文本溢出隐藏</h5><ul>
<li><p>单行文本溢出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行文本溢出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p>
</li>
</ul>
<h5 id="11-为什么需要清除浮动？清除浮动的方式"><a href="#11-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="11.为什么需要清除浮动？清除浮动的方式?"></a>11.为什么需要清除浮动？清除浮动的方式?</h5><p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素会跟随其后</li>
<li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li>
</ul>
<p><strong>清除浮动的方式如下：</strong></p>
<ul>
<li>给父级div定义<code>height</code>属性</li>
<li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li>
<li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li>
<li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li>
</ul>
<h5 id="12-display、float、position的关系"><a href="#12-display、float、position的关系" class="headerlink" title="12.display、float、position的关系"></a>12.display、float、position的关系</h5><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p>
<p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p>
<p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p>
<p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h5 id="13-css3新增的选择符有哪些？"><a href="#13-css3新增的选择符有哪些？" class="headerlink" title="13.css3新增的选择符有哪些？"></a>13.css3新增的选择符有哪些？</h5><p>css3新增的选择器主要分为属性选择器，关系选择器，结构化伪类选择器，伪元素选择器四类，具体介绍如下：</p>
<p><strong>1.属性选择器</strong></p>
<p>属性选择器，可以根据网页标记的属性及属性值来标记。</p>
<p>属性选择器主要包括<code>E[att^=value]</code>、<code>E[att$=value]</code>和<code>E[att*=value]</code>这三种性选择器。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 属性选择符</span><br><span class="line"><span class="selector-attr">[attribute]</span>: 选择所有带有该属性的元素</span><br><span class="line">[attribute=value]: 选择所有带有该属性且值等于给定值的元素</span><br><span class="line">[attribute~=value]: 选择所有带有该属性且值包含给定词汇的元素</span><br><span class="line">[attribute|=value]: 选择所有带有该属性且值以指定字符串开头的元素</span><br><span class="line">[attribute^=value]: 选择所有带有该属性且值以指定字符串开始的元素</span><br><span class="line">[attribute$=value]: 选择所有带有该属性且值以指定字符串结束的元素</span><br><span class="line">[attribute*=value]: 选择所有带有该属性且值包含指定字符串的元素</span><br></pre></td></tr></table></figure>

<p><strong>2.关系选择器</strong></p>
<p>CSS3中的关系选择器主要包括子代选择器和兄弟选择器。</p>
<p>(1)关系选择器</p>
<p>(2)临近兄弟选择器</p>
<p>(3)普通兄弟选择器</p>
<p><strong>3.结构化伪类选择器</strong></p>
<p>结构化伪类选择器可以减少文档内class属性和id属性的定义，使文档变得更加简洁。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1</span> 伪类选择符</span><br><span class="line"><span class="selector-pseudo">:active</span>: 选择当前正在被激活的元素</span><br><span class="line">:checked: 选择所有被选中的元素</span><br><span class="line">:disabled: 选择所有被禁用的元素</span><br><span class="line">:enabled: 选择所有未被禁用的元素</span><br><span class="line">:first-child: 选择某个元素下的第一个子元素</span><br><span class="line">:hover: 选择所有当前鼠标悬停的元素</span><br><span class="line">:<span class="built_in">nth-child</span>(n): 选择某个元素下的第n个子元素</span><br><span class="line">:last-child: 选择某个元素下的最后一个子元素</span><br><span class="line">:<span class="built_in">not</span>(selector): 选择非指定元素的所有元素</span><br><span class="line">:target: 选择当前活动的目标元素</span><br><span class="line"><span class="number">3.2</span>组合选择符</span><br><span class="line">element, element: 选择所有指定元素</span><br><span class="line">element parent: 选择指定元素的父元素</span><br><span class="line">element&gt;child: 选择指定元素的直接子元素</span><br><span class="line">element+element: 选择紧接在指定元素后的元素</span><br><span class="line">element~element: 选择指定元素后的所有同级元素</span><br></pre></td></tr></table></figure>

<p><strong>4.伪元素选择器</strong></p>
<p>伪元素选择器一般使一个标记后紧跟英文冒号”:”，英文冒号后是伪元素名。</p>
<p>伪元素选择器可以帮助我们利用CSS创建新标签元素,而不需要HTML标签,从而简化HTML结构。</p>
<p>：：before      在元素前面插入内容<br>        ：：after         在元素后面插入内容<br>注意</p>
<pre><code>        before和after创建一个元素 ,但是属于行内元素
        新创建的这个元素在文档树中是找不到的,所以我们称为伪元素
        语法: element:before 
        before和after必须有content属性
        before在父元素内容的前面创建元素, after 在父元素内容的后面插入元素
        伪元素选择器和标签选择器一 样,权重为1
</code></pre>
<h4 id="八-ES6"><a href="#八-ES6" class="headerlink" title="八.ES6"></a>八.ES6</h4><h5 id="1-如果new一个箭头函数会怎么样？"><a href="#1-如果new一个箭头函数会怎么样？" class="headerlink" title="1.如果new一个箭头函数会怎么样？"></a>1.如果new一个箭头函数会怎么样？</h5><p>箭头函数是由ES6提出来的，他并没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>
<p>new操作符的实现步骤如下：</p>
<ul>
<li><p>创建一个对象</p>
</li>
<li><p>将构造函数的作用域给新对象</p>
</li>
<li><p>指向构造对象中的代码，构造函数中的this指向该对象</p>
</li>
<li><p>返回新的对象</p>
<p>所以，上面的第二，三步，箭头函数都是没有办法执行的</p>
</li>
</ul>
<h5 id="2-箭头函数和普通函数的区别"><a href="#2-箭头函数和普通函数的区别" class="headerlink" title="2.箭头函数和普通函数的区别"></a>2.箭头函数和普通函数的区别</h5><ul>
<li>箭头函数比普通函数更加简洁<ul>
<li>如果没有参数，就直接写一个空括号即可</li>
<li>如果只有一个参数，可以省去参数的括号</li>
<li>如果有多个参数，用逗号分割</li>
<li>如果函数体的返回值只有一句，可以省略大括号</li>
<li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li>
</ul>
</li>
<li>箭头函数没有自己的this</li>
<li>箭头函数继承来的指向永远不会发生改变</li>
<li>call(),apply(),bind（）等方法不能改变箭头函数的this指向</li>
<li>箭头函数不能作为构造函数使用</li>
<li>箭头函数没有自己的arguments</li>
<li>箭头函数没有prototypes</li>
<li>箭头函数不能做Generator函数，不能使用yeild关键字</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">林南而瑜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">http://example.com/2023/07/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">林南而瑜的星球</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=638285213,1746517464&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/29/node%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="node基础概念"><img class="cover" src="https://img1.baidu.com/it/u=1909763149,4143884418&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">node基础概念</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/15/React%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/" title="React项目搭建"><img class="cover" src="https://img2.baidu.com/it/u=1362505222,3101115598&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React项目搭建</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">林南而瑜</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GuLingc/GuLingc.github.io" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2794957189@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">林南而瑜，与你不期而遇</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E9%97%AD%E5%8C%85%E4%B8%8E%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">一.闭包与原型：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F%E9%97%AD%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.什么是闭包？闭包的用途？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-js%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">二.js基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-JS%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.1.</span> <span class="toc-text">1.JS执行上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-const%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.const定义的对象属性可以被修改吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3.数据类型检测的方式有哪些？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-js%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9F%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">4.js为什么要进行变量提升？会导致什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-js%E6%8F%90%E9%AB%98"><span class="toc-number">4.</span> <span class="toc-text">三.js提高</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%80%E8%BF%B0%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">1.简述事件循环：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9Fdom%E6%98%AF%E4%BB%80%E4%B9%88-%E5%8E%9F%E7%90%86-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">2.虚拟dom是什么? 原理? 优缺点?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B-vue2"><span class="toc-number">5.</span> <span class="toc-text">四.vue2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">1.vue双向绑定的原理是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Computed%E5%92%8CWatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">2.Computed和Watch的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-vue%E4%B8%AD%E7%9A%84keep-alive%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3.vue中的keep-alive的作用是什么？怎么使用？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94-html"><span class="toc-number">6.</span> <span class="toc-text">五.html</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-src%E5%92%8Chref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.</span> <span class="toc-text">1. src和href的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-HTML5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9B%B4%E6%96%B0%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2.HTML5有哪些更新？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%B9HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.3.</span> <span class="toc-text">3.对HTML语义化的理解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD-Ts%EF%BC%88TypeScript%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">六.Ts（TypeScript）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-TS%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">1.TS常用类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ts%E4%B8%ADtype%E5%92%8CInterface%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9A"><span class="toc-number">7.2.</span> <span class="toc-text">2.ts中type和Interface的异同：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83-css"><span class="toc-number">8.</span> <span class="toc-text">七.css</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B5%AE%E5%8A%A8"><span class="toc-number">8.1.</span> <span class="toc-text">1.浮动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">4.什么是重绘和重排？它们的区别是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-dom%E6%A0%91%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">4.dom树是怎么生成的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-display%E7%9A%84block%E3%80%81inline%E5%92%8Cinline-block%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.</span> <span class="toc-text">5. display的block、inline和inline-block的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">8.5.</span> <span class="toc-text">6.隐藏元素的方法有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-link%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.6.</span> <span class="toc-text">7.link和@import的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-CSS3%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">8.7.</span> <span class="toc-text">8.CSS3中有哪些新特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-Sass%E3%80%81Less-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BB%96%E4%BB%AC%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">9.Sass、Less 是什么？为什么要使用他们？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E5%8D%95%E8%A1%8C%E3%80%81%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E9%9A%90%E8%97%8F"><span class="toc-number">8.9.</span> <span class="toc-text">10. 单行、多行文本溢出隐藏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%EF%BC%9F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">8.10.</span> <span class="toc-text">11.为什么需要清除浮动？清除浮动的方式?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-display%E3%80%81float%E3%80%81position%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.11.</span> <span class="toc-text">12.display、float、position的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-css3%E6%96%B0%E5%A2%9E%E7%9A%84%E9%80%89%E6%8B%A9%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">13.css3新增的选择符有哪些？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB-ES6"><span class="toc-number">9.</span> <span class="toc-text">八.ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A6%82%E6%9E%9Cnew%E4%B8%80%E4%B8%AA%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">1.如果new一个箭头函数会怎么样？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.</span> <span class="toc-text">2.箭头函数和普通函数的区别</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/29/node%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="node基础概念"><img src="https://img1.baidu.com/it/u=1909763149,4143884418&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="node基础概念"/></a><div class="content"><a class="title" href="/2023/07/29/node%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="node基础概念">node基础概念</a><time datetime="2023-07-29T12:02:10.000Z" title="发表于 2023-07-29 20:02:10">2023-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/" title="前端面试"><img src="https://img2.baidu.com/it/u=638285213,1746517464&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面试"/></a><div class="content"><a class="title" href="/2023/07/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/" title="前端面试">前端面试</a><time datetime="2023-07-15T01:42:24.000Z" title="发表于 2023-07-15 09:42:24">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/15/React%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/" title="React项目搭建"><img src="https://img2.baidu.com/it/u=1362505222,3101115598&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React项目搭建"/></a><div class="content"><a class="title" href="/2023/07/15/React%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/" title="React项目搭建">React项目搭建</a><time datetime="2023-07-15T01:38:20.000Z" title="发表于 2023-07-15 09:38:20">2023-07-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 林南而瑜</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://gulingc.github.io//">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'WUuShLQfPE7yWJjblEAQprdd-gzGzoHsz',
      appKey: 'OV04qThMaReX1QykhBdwL2V1',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="/js/sakura.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Vue,React,Html,JS,Es6,Node" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>